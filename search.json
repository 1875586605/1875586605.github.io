[{"title":"记录使用微信支付 APIv3 Java SDK的使用和踩的一些坑","path":"/2023/07/13/记录使用微信支付-APIv3-Java-SDK的使用和踩的一些坑/","content":"接入使用引入依赖12345&lt;dependency&gt; &lt;groupId&gt;com.github.wechatpay-apiv3&lt;/groupId&gt; &lt;artifactId&gt;wechatpay-java&lt;/artifactId&gt; &lt;version&gt;0.2.8&lt;/version&gt;&lt;/dependency&gt; 构建全局自动更新平台证书的RSA配置我这里是多商户配置逻辑,所以会根据商户id作为配置的key 1234567891011121314151617181920212223242526private Map&lt;String, RSAAutoCertificateConfig&gt; configMap;public RSAAutoCertificateConfig getConfig(BesaPayReqDTO besaPayReqDTO) &#123; if (configMap == null) &#123; configMap = new HashMap&lt;String, RSAAutoCertificateConfig&gt;(); &#125; RSAAutoCertificateConfig config = configMap.get(besaPayReqDTO.getMerchantId()); if (ObjectUtil.isNotEmpty(config)) &#123; return config; &#125; config = new RSAAutoCertificateConfig.Builder() .merchantId(besaPayReqDTO.getMerchantId()) .privateKey(besaPayReqDTO.getPrivateKey()) .merchantSerialNumber(besaPayReqDTO.getMerchantSerialNumber()) .apiV3Key(besaPayReqDTO.getApiV3key()) .build(); configMap.put(besaPayReqDTO.getMerchantId(), config); return config;&#125; 构建h5网页支付请求1234567891011121314151617181920212223242526272829 /** * wap类型支付方式 * * @param prepayRequest 支付参数 * @param besaPayReqDTO 通用支付配置 * @return */ public String wapPay(PrepayRequest prepayRequest, BesaPayReqDTO besaPayReqDTO, Long merchantId) &#123; RSAAutoCertificateConfig config = getConfig(besaPayReqDTO); // 构建service H5Service service = new H5Service.Builder().config(config).build(); PrepayResponse prepay = null; try &#123; prepay = service.prepay(prepayRequest); &#125; catch (Exception e) &#123; log.error(&quot;订单:&#123;&#125;,调用微信网页支付失败&quot;, prepayRequest.getOutTradeNo()); e.printStackTrace(); throw new RuntimeException(&quot;订单拉起微信支付失败&quot;); &#125; // 缓存支付配置,用于回调验签 redisService.setCacheObject(RedisWechatPayKeyConstant.WECHAT_PAY_CONFIG_CACHE + merchantId, besaPayReqDTO, 3L, TimeUnit.DAYS); return prepay.getH5Url(); &#125;返回h5支付链接给前端,等待用户完成支付 处理订单支付回调123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100/** * 订单支付结果回调 */@PostMapping(&quot;/pay/wap/&#123;merchantId&#125;&quot;)public CallbackRespDTO orderWapPayResult(HttpServletRequest request, HttpServletResponse response, @PathVariable(&quot;merchantId&quot;) Long merchantId) &#123; Transaction transaction = null; try &#123; transaction = callbackCheckSign(request, Transaction.class, merchantId); &#125; catch (Exception e) &#123; log.error(&quot;微信支付回调处理异常,异常原因:&#123;&#125;&quot;, e.getMessage()); e.printStackTrace(); return CallbackRespDTO.fail(response); &#125; if (ObjectUtil.isEmpty(transaction)) &#123; log.error(&quot;微信支付回调参数解析失败!&quot;); return CallbackRespDTO.fail(response); &#125; // 处理回调信息 xxxx.xxxxxxx(transaction) return CallbackRespDTO.success();&#125;/** * 回调验签转换 * * @param &lt;T&gt; * @param request 回调 * @param clazz 参数转换类型 * @param merchantId 商户id * @return */private &lt;T&gt; T callbackCheckSign(HttpServletRequest request, Class&lt;T&gt; clazz, Long merchantId) &#123; //随机串 String nonceStr = request.getHeader(&quot;Wechatpay-Nonce&quot;); //微信传递过来的签名 String signature = request.getHeader(&quot;Wechatpay-Signature&quot;); //证书序列号（微信平台） String serialNo = request.getHeader(&quot;Wechatpay-Serial&quot;); //时间戳 String timestamp = request.getHeader(&quot;Wechatpay-Timestamp&quot;); // 签名类型 String signatureType = request.getHeader(&quot;Wechatpay-Signature-Type&quot;); //获取报文 String body = getRequestBody(request); log.info(&quot;微信支付回调验签nonce:&#123;&#125;,signature:&#123;&#125;,serialNo:&#123;&#125;,timestamp:&#123;&#125;,body:&#123;&#125;&quot;, nonceStr, signature, serialNo, timestamp, body); // 缓存获取配置 BesaPayReqDTO besaPayReqDTO = redisService.getCacheObject(RedisWechatPayKeyConstant.WECHAT_PAY_CONFIG_CACHE + merchantId); // 构造 RequestParam RequestParam requestParam = new RequestParam.Builder() .serialNumber(serialNo) .nonce(nonceStr) .signature(signature) .timestamp(timestamp) .signType(signatureType) .body(body) .build(); NotificationConfig config = wechatPayService.getConfig(besaPayReqDTO); NotificationParser parser = new NotificationParser(config); return parser.parse(requestParam, clazz);&#125;/** * 读取请求数据流 * * @param request * @return */private String getRequestBody(HttpServletRequest request) &#123; try &#123; ByteArrayOutputStream result = new ByteArrayOutputStream(); ServletInputStream inputStream = request.getInputStream(); byte[] buffer = new byte[1024]; for (int length; (length = inputStream.read(buffer)) != -1; ) &#123; result.write(buffer, 0, length); &#125; return result.toString(&quot;UTF-8&quot;); &#125; catch (Exception e) &#123; log.error(&quot;读取数据流异常:&#123;&#125;&quot;, e); &#125; return null;&#125; 订单请求退款123456789101112131415161718192021/** * 退款 * * @param createRequest 支付参数 * @param besaPayReqDTO 通用支付配置 * @return */public Refund refund(CreateRequest createRequest, BesaPayReqDTO besaPayReqDTO, Long merchantId) &#123; RSAAutoCertificateConfig config = getConfig(besaPayReqDTO); // 构建service RefundService refundService = new RefundService.Builder().config(config).build(); Refund refund = null; try &#123; refund = refundService.create(createRequest); &#125; catch (Exception e) &#123; log.error(&quot;退款订单:&#123;&#125;,退款失败,退款单号:&#123;&#125;&quot;, createRequest.getOutTradeNo(), createRequest.getOutRefundNo()); throw new RuntimeException(e); &#125; redisService.setCacheObject(RedisWechatPayKeyConstant.WECHAT_PAY_CONFIG_CACHE + merchantId, besaPayReqDTO, 3L, TimeUnit.DAYS); return refund;&#125; 退款回调处理1234567891011121314151617181920/** * 退款结果回调 */@PostMapping(&quot;/refund/&#123;merchantId&#125;&quot;)public CallbackRespDTO orderRefundResult(HttpServletRequest request, HttpServletResponse response, @PathVariable(&quot;merchantId&quot;) Long merchantId) &#123; //获取报文 RefundNotification refundNotification = null; try &#123; refundNotification = callbackCheckSign(request, RefundNotification.class, merchantId); &#125; catch (Exception e) &#123; log.error(&quot;微信退款回调处理异常,异常原因:&#123;&#125;&#125;&quot;, e.getMessage()); e.printStackTrace(); return CallbackRespDTO.fail(response); &#125; // 处理回调信息 xxxx.xxxxxxx(refundNotification) return CallbackRespDTO.success();&#125; 使用中碰到的一些问题RSAAutoCertificateConfig配置多次初始化问题原写法是参考官方文档上的内容直接进行构建,导致在第二次请求支付时处出现证书配置初始化错误问题 github类似问题issues https://github.com/wechatpay-apiv3/wechatpay-java/issues/130 错误的H5支付构建方式12345678910111213141516171819202122232425262728/** * wap类型支付方式 * @param prepayRequest 支付参数 * @param besaPayReqDTO 通用支付配置 * @return */public String wapPay(PrepayRequest prepayRequest, BesaPayReqDTO besaPayReqDTO,Long merchantId) &#123; Config config = new RSAAutoCertificateConfig.Builder() .merchantId(besaPayReqDTO.getMerchantId()) .privateKey(besaPayReqDTO.getPrivateKey()) .merchantSerialNumber(besaPayReqDTO.getMerchantSerialNumber()) .apiV3Key(besaPayReqDTO.getApiV3key()) .build(); // 构建service H5Service service = new H5Service.Builder().config(config).build(); PrepayResponse prepay = null; try &#123; prepay = service.prepay(prepayRequest); &#125; catch (Exception e) &#123; log.error(&quot;订单:&#123;&#125;,调用微信网页支付失败&quot;, prepayRequest.getOutTradeNo()); e.printStackTrace(); throw new RuntimeException(&quot;订单拉起微信支付失败&quot;); &#125; return prepay.getH5Url();&#125; 支付状态回调验签问题github类似问题issues https://github.com/wechatpay-apiv3/wechatpay-java/issues/120 回调验签的请求体的读取方式错误导致缺少空格、换行等字符或者进行了JSON序列化导致验签失败错误代码1234567891011121314151617181920212223242526/** * 读取请求数据流 * * @param request * @return */private String getRequestBody(HttpServletRequest request) &#123; StringBuffer sb = new StringBuffer(); try (ServletInputStream inputStream = request.getInputStream(); BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream)); ) &#123; String line; while ((line = reader.readLine()) != null) &#123; sb.append(line); &#125; &#125; catch (IOException e) &#123; log.error(&quot;读取数据流异常:&#123;&#125;&quot;, e); &#125; return sb.toString();&#125; 构建验签requestParam时serialNumber使用了配置里面的证书编号导致验签出错,构建时需要使用请求头中返回的证书编号;在guthub的issues中存在非常多的同类型错误问题一定要注意,天坑!!! 错误代码1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * 回调验签转换 * * @param &lt;T&gt; * @param request 回调 * @param clazz 参数转换类型 * @param merchantId 商户id * @param body * @return */private &lt;T&gt; T callbackCheckSign(HttpServletRequest request, Class&lt;T&gt; clazz, Long merchantId, String body) &#123; //随机串 String nonceStr = request.getHeader(&quot;Wechatpay-Nonce&quot;); //微信传递过来的签名 String signature = request.getHeader(&quot;Wechatpay-Signature&quot;); //证书序列号（微信平台） String serialNo = request.getHeader(&quot;Wechatpay-Serial&quot;); //时间戳 String timestamp = request.getHeader(&quot;Wechatpay-Timestamp&quot;); // 缓存获取配置 BesaPayReqDTO besaPayReqDTO = redisService.getCacheObject(RedisWechatPayKeyConstant.WECHAT_PAY_CONFIG_CACHE + merchantId); if (besaPayReqDTO.getMerchantSerialNumber().equals(serialNo)) &#123; throw new RuntimeException(&quot;回调证书序列号和请求序列号不一致!&quot;); &#125; // 构造 RequestParam RequestParam requestParam = new RequestParam.Builder() .serialNumber(besaPayReqDTO.getMerchantSerialNumber()) .nonce(nonceStr) .signature(signature) .timestamp(timestamp) .body(body) .build(); NotificationConfig config = wechatPayService.getConfig(besaPayReqDTO); NotificationParser parser = new NotificationParser(config); return parser.parse(requestParam, clazz);&#125;"},{"title":"aws toolkit AI代码提示工具使用教程和个人感受","path":"/2023/06/19/aws-toolkit-AI代码提示工具使用教程和个人感受/","content":"idea安装 aws toolkit下载插件安装并启用,重启idea 申请亚马逊账号注册流程中需要使用外币信用卡进行实名验证,需要提前准备哦 https://aws.amazon.com/cn/ 登录到控制台配置访问秘钥 填写秘钥信息 选择账户 授权连接代码AI提示服务器 复制授权码 填入授权码 授权权限 显示授权成功 启动代码自动提示 使用体验输入部分代码后自动提示,或者输入一行注释后回车也会出现生成提示 快捷键 :tab 使用提示代码直接补全 方向键 前 查看下一个提示方向键 后 查看前一个提示 使用感受补全功能大概在5次里面有一次以上的可用代码,对于代码编写的速度还是有提升的,对于我这种创建方法和实体字段名称纠结的能起到很好的帮助,总体来说是非常值得体验的,目前是可以白嫖阶段,香!"},{"title":"实现通用文件上传,三方云通过s3协议实现","path":"/2023/06/06/实现通用文件上传-三方云通过s3协议实现/","content":"目录结构1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677└─file │ pom.xml └─src ├─main │ ├─java │ │ └─common │ │ └─file │ │ ├─config │ │ │ FileAutoConfiguration.java │ │ │ FileConfigConfiguration.java │ │ │ FileConfigDTO.java │ │ │ │ │ └─core │ │ ├─client │ │ │ │ AbstractFileClient.java │ │ │ │ FileClient.java │ │ │ │ FileClientConfig.java │ │ │ │ FileClientFactory.java │ │ │ │ FileClientFactoryImpl.java │ │ │ │ │ │ │ ├─db │ │ │ │ DBFileClient.java │ │ │ │ DBFileClientConfig.java │ │ │ │ DBFileContentFrameworkDAO.java │ │ │ │ │ │ │ ├─ftp │ │ │ │ FtpFileClient.java │ │ │ │ FtpFileClientConfig.java │ │ │ │ │ │ │ ├─local │ │ │ │ LocalFileClient.java │ │ │ │ LocalFileClientConfig.java │ │ │ │ │ │ │ ├─s3 │ │ │ │ S3FileClient.java │ │ │ │ S3FileClientConfig.java │ │ │ │ │ │ │ └─sftp │ │ │ SftpFileClient.java │ │ │ SftpFileClientConfig.java │ │ │ │ │ ├─enums │ │ │ FileStorageEnum.java │ │ │ │ │ └─utils │ │ FileClientUtils.java │ │ FileTypeUtils.java │ │ FileUtils.java │ │ │ └─resources │ └─META-INF │ └─spring │ org.springframework.boot.autoconfigure.AutoConfiguration.imports │ └─test ├─java │ └─common │ └─file │ ├─config │ └─core │ ├─client │ │ ├─ftp │ │ │ FtpFileClientTest.java │ │ │ │ │ ├─local │ │ │ LocalFileClientTest.java │ │ │ │ │ ├─s3 │ │ │ S3FileClientTest.java │ │ │ │ │ └─sftp │ │ SftpFileClientTest.java │ │ │ └─enums └─resources └─file test.png 项目源码地址https://github.com/1875586605/common-file 项目pom文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;description&gt; 1. file：本地磁盘 2. ftp：FTP 服务器 2. sftp：SFTP 服务器 4. db：数据库 5. s3：支持 S3 协议的云存储服务，例如说 MinIO、阿里云、华为云、腾讯云、七牛云等等 &lt;/description&gt; &lt;groupId&gt;demo&lt;/groupId&gt; &lt;artifactId&gt;file&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;transmittable-thread-local&lt;/artifactId&gt; &lt;version&gt;2.14.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.26&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.jcraft&lt;/groupId&gt; &lt;artifactId&gt;jsch&lt;/artifactId&gt; &lt;!-- 解决 sftp 连接 --&gt; &lt;version&gt;0.1.55&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tika&lt;/groupId&gt; &lt;artifactId&gt;tika-core&lt;/artifactId&gt; &lt;!-- 文件类型的识别 --&gt; &lt;version&gt;2.7.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;cn.hutool&lt;/groupId&gt; &lt;artifactId&gt;hutool-all&lt;/artifactId&gt; &lt;version&gt;5.8.16&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 三方云服务相关 --&gt; &lt;dependency&gt; &lt;groupId&gt;io.minio&lt;/groupId&gt; &lt;artifactId&gt;minio&lt;/artifactId&gt; &lt;version&gt;8.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt; &lt;version&gt;2.7.10&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;version&gt;2.7.10&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 配置类代码自动注入配置类1234567891011121314151617181920package common.file.config;import common.file.core.client.FileClientFactory;import common.file.core.client.FileClientFactoryImpl;import org.springframework.boot.autoconfigure.AutoConfiguration;import org.springframework.context.annotation.Bean;/** * 文件配置类 */@AutoConfigurationpublic class FileAutoConfiguration &#123; @Bean public FileClientFactory fileClientFactory() &#123; return new FileClientFactoryImpl(); &#125;&#125; 文件配置类数据模型1234567891011121314151617181920212223242526272829303132333435363738394041package common.file.config;import common.file.core.client.FileClientConfig;import common.file.core.enums.FileStorageEnum;import lombok.Data;/** * @author cjb * @date 2023/5/9 9:48 * @describe */@Datapublic class FileConfigDTO &#123; /** * 配置名 */ private String name; /** * 存储器 * &lt;p&gt; * 枚举 &#123;@link FileStorageEnum&#125; */ private String storage; /** * 是否为主配置 * &lt;p&gt; * 由于我们可以配置多个文件配置，默认情况下，使用主配置进行文件的上传 */ private Boolean master; /** * 配置文件详情 */ private FileClientConfig config;&#125; 配置参数读取注入类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package common.file.config;import cn.hutool.core.bean.BeanDesc;import cn.hutool.core.bean.BeanUtil;import cn.hutool.core.bean.PropDesc;import cn.hutool.core.util.ObjectUtil;import cn.hutool.extra.spring.SpringUtil;import common.file.core.client.FileClientConfig;import common.file.core.enums.FileStorageEnum;import lombok.Data;import lombok.extern.slf4j.Slf4j;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.stereotype.Component;import javax.annotation.PostConstruct;import java.util.*;/** * @author cjb * @date 2023/5/9 9:38 * @describe 文件配置类 */@Slf4j@Data@Component@ConfigurationProperties(prefix = &quot;file.conf&quot;)public class FileConfigConfiguration &#123; private Map&lt;String, FileConfigDTO&gt; confMap; @PostConstruct public void init() &#123; log.info(&quot;初始化数据文件配置,进行多态配置&quot;); for (String key : confMap.keySet()) &#123; FileConfigDTO fileConfigDTO = confMap.get(key); FileStorageEnum storageEnum = FileStorageEnum.getByStorage(fileConfigDTO.getStorage()); String propertyKeyPrefix = &quot;file.conf.confMap.&quot; + fileConfigDTO.getName() + &quot;.config.&quot;; HashMap&lt;String, Object&gt; beanMap = new HashMap&lt;&gt;(); BeanDesc beanDesc = BeanUtil.getBeanDesc(storageEnum.getConfigClass()); Collection&lt;PropDesc&gt; props = beanDesc.getProps(); for (PropDesc prop : props) &#123; String fieldName = prop.getFieldName(); String propertyKey = propertyKeyPrefix + fieldName; String fieldValue = SpringUtil.getProperty(propertyKey); if (ObjectUtil.isNotEmpty(fieldValue)) &#123; beanMap.put(fieldName, fieldValue); &#125; &#125; FileClientConfig bean = BeanUtil.toBean(beanMap, storageEnum.getConfigClass()); fileConfigDTO.setConfig(bean); &#125; log.info(&quot;初始化数据文件配置,多态配置完成&quot;); &#125; public FileConfigDTO getConfByKey(String key) &#123; return this.confMap.get(key); &#125; public List&lt;FileConfigDTO&gt; getFileConfList() &#123; ArrayList&lt;FileConfigDTO&gt; fileConfigDTOS = new ArrayList&lt;&gt;(); for (String key : this.confMap.keySet()) &#123; fileConfigDTOS.add(this.confMap.get(key)); &#125; return fileConfigDTOS; &#125;&#125; 配置文件示例1234567891011121314151617181920212223242526272829303132file: conf: confMap: # 配置名称 aliyunPreA: name: aliyunPreA # 存储器类型 storage: s3 # 是否为主配置 master: false # 详细参数配置 config: # 节点地址 endpoint: oss-cn-hangzhou.aliyuncs.com # 自定义域名 domain: xxx.oss-cn-hangzhou.aliyuncs.com # 存储桶名称 bucket: xxx # 访问 Key accessKey: xxxxxxxxx # 访问 Secret accessSecret: xxxxxxxxx aliyunPreB: name: aliyunPreB storage: s3 master: true config: endpoint: oss-cn-hangzhou.aliyuncs.com domain: xxxxxx.oss-cn-hangzhou.aliyuncs.com bucket: xxxxxx accessKey: xxxxxxxxx accessSecret: xxxxxxxxx 枚举代码文件存储器枚举1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package common.file.core.enums;import cn.hutool.core.util.ArrayUtil;import common.file.core.client.FileClient;import common.file.core.client.FileClientConfig;import common.file.core.client.db.DBFileClient;import common.file.core.client.db.DBFileClientConfig;import common.file.core.client.ftp.FtpFileClient;import common.file.core.client.ftp.FtpFileClientConfig;import common.file.core.client.local.LocalFileClient;import common.file.core.client.local.LocalFileClientConfig;import common.file.core.client.s3.S3FileClient;import common.file.core.client.s3.S3FileClientConfig;import common.file.core.client.sftp.SftpFileClient;import common.file.core.client.sftp.SftpFileClientConfig;import lombok.AllArgsConstructor;import lombok.Getter;/** * 文件存储器枚举 * * @author */@AllArgsConstructor@Getterpublic enum FileStorageEnum &#123; DB(&quot;db&quot;, DBFileClientConfig.class, DBFileClient.class), LOCAL(&quot;local&quot;, LocalFileClientConfig.class, LocalFileClient.class), FTP(&quot;ftp&quot;, FtpFileClientConfig.class, FtpFileClient.class), SFTP(&quot;sftp&quot;, SftpFileClientConfig.class, SftpFileClient.class), S3(&quot;s3&quot;, S3FileClientConfig.class, S3FileClient.class), ; /** * 存储器 */ private final String storage; /** * 配置类 */ private final Class&lt;? extends FileClientConfig&gt; configClass; /** * 客户端类 */ private final Class&lt;? extends FileClient&gt; clientClass; public static FileStorageEnum getByStorage(String storage) &#123; return ArrayUtil.firstMatch(o -&gt; o.getStorage().equals(storage), values()); &#125;&#125; 上传核心代码通用接口定义相关代码文件客户端的抽象类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package common.file.core.client;import cn.hutool.core.util.StrUtil;import lombok.extern.slf4j.Slf4j;/** * 文件客户端的抽象类，提供模板方法，减少子类的冗余代码 */@Slf4jpublic abstract class AbstractFileClient&lt;Config extends FileClientConfig&gt; implements FileClient &#123; /** * 配置编号 */ private final String confKey; /** * 文件配置 */ protected Config config; public AbstractFileClient(String confKey, Config config) &#123; this.confKey = confKey; this.config = config; &#125; /** * 初始化 */ public final void init() &#123; doInit(); log.info(&quot;[init][配置(&#123;&#125;) 初始化完成]&quot;, config); &#125; /** * 自定义初始化 */ protected abstract void doInit(); public final void refresh(Config config) &#123; // 判断是否更新 if (config.equals(this.config)) &#123; return; &#125; log.info(&quot;[refresh][配置(&#123;&#125;)发生变化，重新初始化]&quot;, config); this.config = config; // 初始化 this.init(); &#125; @Override public String getConfKey() &#123; return confKey; &#125; /** * 格式化文件的 URL 访问地址 * 使用场景：local、ftp、db，通过 FileController 的 getFile 来获取文件内容 * * @param domain 自定义域名 * @param path 文件路径 * @return URL 访问地址 */ protected String formatFileUrl(String domain, String path) &#123; return StrUtil.format(&quot;&#123;&#125;/admin-api/infra/file/&#123;&#125;/get/&#123;&#125;&quot;, domain, getConfKey(), path); &#125;&#125; 文件客户端接口定义123456789101112131415161718192021222324252627282930313233343536373839404142package common.file.core.client;/** * 文件客户端 */public interface FileClient &#123; /** * 获得客户端编号 * * @return 客户端编号 */ String getConfKey(); /** * 上传文件 * * @param content 文件流 * @param path 相对路径 * @return 完整路径，即 HTTP 访问地址 * @throws Exception 上传文件时，抛出 Exception 异常 */ String upload(byte[] content, String path, String type) throws Exception; /** * 删除文件 * * @param path 相对路径 * @throws Exception 删除文件时，抛出 Exception 异常 */ void delete(String path) throws Exception; /** * 获得文件的内容 * * @param path 相对路径 * @return 文件的内容 */ byte[] getContent(String path) throws Exception;&#125; 文件客户端的配置接口12345678910package common.file.core.client;/** * 文件客户端的配置 * 不同实现的客户端，需要不同的配置，通过子类来定义 */public interface FileClientConfig &#123;&#125; 文件客户端获取工厂1234567891011121314151617181920212223package common.file.core.client;public interface FileClientFactory &#123; /** * 获得文件客户端 * * @param configKey 配置编号 * @return 文件客户端 */ FileClient getFileClient(String configKey); /** * 创建文件客户端 * * @param confKey 配置key * @param storage 存储器的枚举 &#123;@link FileClientFactoryImpl&#125; * @param config 文件配置 */ &lt;Config extends FileClientConfig&gt; void createOrUpdateFileClient(String confKey, String storage, Config config);&#125; 文件客户端的工厂实现类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package common.file.core.client;import cn.hutool.core.lang.Assert;import cn.hutool.core.util.ReflectUtil;import common.file.core.enums.FileStorageEnum;import lombok.extern.slf4j.Slf4j;import java.util.concurrent.ConcurrentHashMap;import java.util.concurrent.ConcurrentMap;/** * 文件客户端的工厂实现类 */@Slf4jpublic class FileClientFactoryImpl implements FileClientFactory &#123; /** * 文件客户端 Map * key：配置编号 */ private final ConcurrentMap&lt;String, AbstractFileClient&lt;?&gt;&gt; clients = new ConcurrentHashMap&lt;&gt;(); @Override public FileClient getFileClient(String configKey) &#123; AbstractFileClient&lt;?&gt; client = clients.get(configKey); if (client == null) &#123; log.error(&quot;[getFileClient][配置编号(&#123;&#125;) 找不到客户端]&quot;, configKey); &#125; return client; &#125; @Override @SuppressWarnings(&quot;unchecked&quot;) public &lt;Config extends FileClientConfig&gt; void createOrUpdateFileClient(String confKey, String storage, Config config) &#123; AbstractFileClient&lt;Config&gt; client = (AbstractFileClient&lt;Config&gt;) clients.get(confKey); if (client == null) &#123; client = this.createFileClient(confKey, storage, config); client.init(); clients.put(client.getConfKey(), client); &#125; else &#123; client.refresh(config); &#125; &#125; @SuppressWarnings(&quot;unchecked&quot;) private &lt;Config extends FileClientConfig&gt; AbstractFileClient&lt;Config&gt; createFileClient( String confKey, String storage, Config config) &#123; FileStorageEnum storageEnum = FileStorageEnum.getByStorage(storage); Assert.notNull(storageEnum, String.format(&quot;文件配置(%s) 为空&quot;, storageEnum)); // 创建客户端 return (AbstractFileClient&lt;Config&gt;) ReflectUtil.newInstance(storageEnum.getClientClass(), confKey, config); &#125;&#125; db上传客户端基于 DB 存储的文件客户端的配置类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package common.file.core.client.db;import cn.hutool.extra.spring.SpringUtil;import common.file.core.client.AbstractFileClient;/** * 基于 DB 存储的文件客户端的配置类 */public class DBFileClient extends AbstractFileClient&lt;DBFileClientConfig&gt; &#123; private DBFileContentFrameworkDAO dao; public DBFileClient(String confKey, DBFileClientConfig config) &#123; super(confKey, config); &#125; @Override protected void doInit() &#123; &#125; @Override public String upload(byte[] content, String path, String type) &#123; getDao().insert(getConfKey(), path, content); // 拼接返回路径 return super.formatFileUrl(config.getDomain(), path); &#125; @Override public void delete(String path) &#123; getDao().delete(getConfKey(), path); &#125; @Override public byte[] getContent(String path) &#123; return getDao().selectContent(getConfKey(), path); &#125; private DBFileContentFrameworkDAO getDao() &#123; // 延迟获取，因为 SpringUtil 初始化太慢 if (dao == null) &#123; dao = SpringUtil.getBean(DBFileContentFrameworkDAO.class); &#125; return dao; &#125;&#125; 基于 DB 存储的文件客户端的配置类1234567891011121314151617181920212223package common.file.core.client.db;import common.file.core.client.FileClientConfig;import lombok.Data;import org.hibernate.validator.constraints.URL;import javax.validation.constraints.NotEmpty;/** * 基于 DB 存储的文件客户端的配置类 */@Datapublic class DBFileClientConfig implements FileClientConfig &#123; /** * 自定义域名 */ @NotEmpty(message = &quot;domain 不能为空&quot;) @URL(message = &quot;domain 必须是 URL 格式&quot;) private String domain;&#125; 文件内容 Framework DAO 接口1234567891011121314151617181920212223242526272829303132333435package common.file.core.client.db;/** * 文件内容 Framework DAO 接口 */public interface DBFileContentFrameworkDAO &#123; /** * 插入文件内容 * * @param confKey 配置编号 * @param path 路径 * @param content 内容 */ void insert(String confKey, String path, byte[] content); /** * 删除文件内容 * * @param confKey 配置编号 * @param path 路径 */ void delete(String confKey, String path); /** * 获得文件内容 * * @param confKey 配置编号 * @param path 路径 * @return 内容 */ byte[] selectContent(String confKey, String path);&#125; FTP上传客户端FTP 文件客户端123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475package common.file.core.client.ftp;import cn.hutool.core.io.FileUtil;import cn.hutool.core.util.CharsetUtil;import cn.hutool.core.util.StrUtil;import cn.hutool.extra.ftp.Ftp;import cn.hutool.extra.ftp.FtpException;import cn.hutool.extra.ftp.FtpMode;import common.file.core.client.AbstractFileClient;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;/** * Ftp 文件客户端 */public class FtpFileClient extends AbstractFileClient&lt;FtpFileClientConfig&gt; &#123; private Ftp ftp; public FtpFileClient(String confKey, FtpFileClientConfig config) &#123; super(confKey, config); &#125; @Override protected void doInit() &#123; // 把配置的 \\ 替换成 /, 如果路径配置 \\a\\test, 替换成 /a/test, 替换方法已经处理 null 情况 config.setBasePath(StrUtil.replace(config.getBasePath(), StrUtil.BACKSLASH, StrUtil.SLASH)); // ftp的路径是 / 结尾 if (!config.getBasePath().endsWith(StrUtil.SLASH)) &#123; config.setBasePath(config.getBasePath() + StrUtil.SLASH); &#125; // 初始化 Ftp 对象 this.ftp = new Ftp(config.getHost(), config.getPort(), config.getUsername(), config.getPassword(), CharsetUtil.CHARSET_UTF_8, null, null, FtpMode.valueOf(config.getMode())); &#125; @Override public String upload(byte[] content, String path, String type) &#123; // 执行写入 String filePath = getFilePath(path); String fileName = FileUtil.getName(filePath); String dir = StrUtil.removeSuffix(filePath, fileName); ftp.reconnectIfTimeout(); boolean success = ftp.upload(dir, fileName, new ByteArrayInputStream(content)); if (!success) &#123; throw new FtpException(StrUtil.format(&quot;上传文件到目标目录 (&#123;&#125;) 失败&quot;, filePath)); &#125; // 拼接返回路径 return super.formatFileUrl(config.getDomain(), path); &#125; @Override public void delete(String path) &#123; String filePath = getFilePath(path); ftp.reconnectIfTimeout(); ftp.delFile(filePath); &#125; @Override public byte[] getContent(String path) &#123; String filePath = getFilePath(path); String fileName = FileUtil.getName(filePath); String dir = StrUtil.removeSuffix(filePath, fileName); ByteArrayOutputStream out = new ByteArrayOutputStream(); ftp.reconnectIfTimeout(); ftp.download(dir, fileName, out); return out.toByteArray(); &#125; private String getFilePath(String path) &#123; return config.getBasePath() + path; &#125;&#125; FTP 文件客户端的配置类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package common.file.core.client.ftp;import common.file.core.client.FileClientConfig;import lombok.Data;import org.hibernate.validator.constraints.URL;import javax.validation.constraints.NotEmpty;import javax.validation.constraints.NotNull;/** * Ftp 文件客户端的配置类 */@Datapublic class FtpFileClientConfig implements FileClientConfig &#123; /** * 基础路径 */ @NotEmpty(message = &quot;基础路径不能为空&quot;) private String basePath; /** * 自定义域名 */ @NotEmpty(message = &quot;domain 不能为空&quot;) @URL(message = &quot;domain 必须是 URL 格式&quot;) private String domain; /** * 主机地址 */ @NotEmpty(message = &quot;host 不能为空&quot;) private String host; /** * 主机端口 */ @NotNull(message = &quot;port 不能为空&quot;) private Integer port; /** * 用户名 */ @NotEmpty(message = &quot;用户名不能为空&quot;) private String username; /** * 密码 */ @NotEmpty(message = &quot;密码不能为空&quot;) private String password; /** * 连接模式 * &lt;p&gt; * 使用 &#123;@link cn.hutool.extra.ftp.FtpMode&#125; 对应的字符串 */ @NotEmpty(message = &quot;连接模式不能为空&quot;) private String mode;&#125; 基于本地的上传本地文件客户端123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package common.file.core.client.local;import cn.hutool.core.io.FileUtil;import common.file.core.client.AbstractFileClient;import java.io.File;/** * 本地文件客户端 */public class LocalFileClient extends AbstractFileClient&lt;LocalFileClientConfig&gt; &#123; public LocalFileClient(String confKey, LocalFileClientConfig config) &#123; super(confKey, config); &#125; @Override protected void doInit() &#123; // 补全风格。例如说 Linux 是 /，Windows 是 \\ if (!config.getBasePath().endsWith(File.separator)) &#123; config.setBasePath(config.getBasePath() + File.separator); &#125; &#125; @Override public String upload(byte[] content, String path, String type) &#123; // 执行写入 String filePath = getFilePath(path); FileUtil.writeBytes(content, filePath); // 拼接返回路径 return super.formatFileUrl(config.getDomain(), path); &#125; @Override public void delete(String path) &#123; String filePath = getFilePath(path); FileUtil.del(filePath); &#125; @Override public byte[] getContent(String path) &#123; String filePath = getFilePath(path); return FileUtil.readBytes(filePath); &#125; private String getFilePath(String path) &#123; return config.getBasePath() + path; &#125;&#125; 本地文件客户端的配置类1234567891011121314151617181920212223242526272829package common.file.core.client.local;import common.file.core.client.FileClientConfig;import lombok.Data;import org.hibernate.validator.constraints.URL;import javax.validation.constraints.NotEmpty;/** * 本地文件客户端的配置类 */@Datapublic class LocalFileClientConfig implements FileClientConfig &#123; /** * 基础路径 */ @NotEmpty(message = &quot;基础路径不能为空&quot;) private String basePath; /** * 自定义域名 */ @NotEmpty(message = &quot;domain 不能为空&quot;) @URL(message = &quot;domain 必须是 URL 格式&quot;) private String domain;&#125; SFTP上传SFTP 文件客户端1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package common.file.core.client.sftp;import cn.hutool.core.io.FileUtil;import cn.hutool.extra.ssh.Sftp;import common.file.core.client.AbstractFileClient;import common.file.core.utils.FileUtils;import java.io.File;/** * Sftp 文件客户端 * */public class SftpFileClient extends AbstractFileClient&lt;SftpFileClientConfig&gt; &#123; private Sftp sftp; public SftpFileClient(String confKey, SftpFileClientConfig config) &#123; super(confKey, config); &#125; @Override protected void doInit() &#123; // 补全风格。例如说 Linux 是 /，Windows 是 \\ if (!config.getBasePath().endsWith(File.separator)) &#123; config.setBasePath(config.getBasePath() + File.separator); &#125; // 初始化 Ftp 对象 this.sftp = new Sftp(config.getHost(), config.getPort(), config.getUsername(), config.getPassword()); &#125; @Override public String upload(byte[] content, String path, String type) &#123; // 执行写入 String filePath = getFilePath(path); File file = FileUtils.createTempFile(content); sftp.upload(filePath, file); // 拼接返回路径 return super.formatFileUrl(config.getDomain(), path); &#125; @Override public void delete(String path) &#123; String filePath = getFilePath(path); sftp.delFile(filePath); &#125; @Override public byte[] getContent(String path) &#123; String filePath = getFilePath(path); File destFile = FileUtils.createTempFile(); sftp.download(filePath, destFile); return FileUtil.readBytes(destFile); &#125; private String getFilePath(String path) &#123; return config.getBasePath() + path; &#125;&#125; SFTP 文件客户端的配置类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package common.file.core.client.sftp;import common.file.core.client.FileClientConfig;import lombok.Data;import org.hibernate.validator.constraints.URL;import javax.validation.constraints.NotEmpty;import javax.validation.constraints.NotNull;/** * Sftp 文件客户端的配置类 */@Datapublic class SftpFileClientConfig implements FileClientConfig &#123; /** * 基础路径 */ @NotEmpty(message = &quot;基础路径不能为空&quot;) private String basePath; /** * 自定义域名 */ @NotEmpty(message = &quot;domain 不能为空&quot;) @URL(message = &quot;domain 必须是 URL 格式&quot;) private String domain; /** * 主机地址 */ @NotEmpty(message = &quot;host 不能为空&quot;) private String host; /** * 主机端口 */ @NotNull(message = &quot;port 不能为空&quot;) private Integer port; /** * 用户名 */ @NotEmpty(message = &quot;用户名不能为空&quot;) private String username; /** * 密码 */ @NotEmpty(message = &quot;密码不能为空&quot;) private String password;&#125; 基于s3协议上传文件 实现 MinIO、阿里云、腾讯云、七牛云、华为云等云服务基于 S3 协议的文件客户端123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120package common.file.core.client.s3;import cn.hutool.core.io.IoUtil;import cn.hutool.core.util.StrUtil;import cn.hutool.http.HttpUtil;import common.file.core.client.AbstractFileClient;import io.minio.*;import java.io.ByteArrayInputStream;import static common.file.core.client.s3.S3FileClientConfig.ENDPOINT_ALIYUN;import static common.file.core.client.s3.S3FileClientConfig.ENDPOINT_TENCENT;/** * 基于 S3 协议的文件客户端，实现 MinIO、阿里云、腾讯云、七牛云、华为云等云服务 * &lt;p&gt; * S3 协议的客户端，采用亚马逊提供的 software.amazon.awssdk.s3 库 */public class S3FileClient extends AbstractFileClient&lt;S3FileClientConfig&gt; &#123; private MinioClient client; public S3FileClient(String confKey, S3FileClientConfig config) &#123; super(confKey, config); &#125; @Override protected void doInit() &#123; // 补全 domain if (StrUtil.isEmpty(config.getDomain())) &#123; config.setDomain(buildDomain()); &#125; // 初始化客户端 client = MinioClient.builder() .endpoint(buildEndpointURL()) // Endpoint URL .region(buildRegion()) // Region .credentials(config.getAccessKey(), config.getAccessSecret()) // 认证密钥 .build(); &#125; /** * 基于 endpoint 构建调用云服务的 URL 地址 * * @return URI 地址 */ private String buildEndpointURL() &#123; // 如果已经是 http 或者 https，则不进行拼接.主要适配 MinIO if (HttpUtil.isHttp(config.getEndpoint()) || HttpUtil.isHttps(config.getEndpoint())) &#123; return config.getEndpoint(); &#125; return StrUtil.format(&quot;https://&#123;&#125;&quot;, config.getEndpoint()); &#125; /** * 基于 bucket + endpoint 构建访问的 Domain 地址 * * @return Domain 地址 */ private String buildDomain() &#123; // 如果已经是 http 或者 https，则不进行拼接.主要适配 MinIO if (HttpUtil.isHttp(config.getEndpoint()) || HttpUtil.isHttps(config.getEndpoint())) &#123; return StrUtil.format(&quot;&#123;&#125;/&#123;&#125;&quot;, config.getEndpoint(), config.getBucket()); &#125; // 阿里云、腾讯云、华为云都适合。七牛云比较特殊，必须有自定义域名 return StrUtil.format(&quot;https://&#123;&#125;.&#123;&#125;&quot;, config.getBucket(), config.getEndpoint()); &#125; /** * 基于 bucket 构建 region 地区 * * @return region 地区 */ private String buildRegion() &#123; // 阿里云必须有 region，否则会报错 if (config.getEndpoint().contains(ENDPOINT_ALIYUN)) &#123; return StrUtil.subBefore(config.getEndpoint(), &#x27;.&#x27;, false) .replaceAll(&quot;-internal&quot;, &quot;&quot;)// 去除内网 Endpoint 的后缀 .replaceAll(&quot;https://&quot;, &quot;&quot;); &#125; // 腾讯云必须有 region，否则会报错 if (config.getEndpoint().contains(ENDPOINT_TENCENT)) &#123; return StrUtil.subAfter(config.getEndpoint(), &quot;.cos.&quot;, false) .replaceAll(&quot;.&quot; + ENDPOINT_TENCENT, &quot;&quot;); // 去除 Endpoint &#125; return null; &#125; @Override public String upload(byte[] content, String path, String type) throws Exception &#123; // 执行上传 client.putObject(PutObjectArgs.builder() .bucket(config.getBucket()) // bucket 必须传递 .contentType(type) .object(path) // 相对路径作为 key .stream(new ByteArrayInputStream(content), content.length, -1) // 文件内容 .build()); // 拼接返回路径 return config.getDomain() + &quot;/&quot; + path; &#125; @Override public void delete(String path) throws Exception &#123; client.removeObject(RemoveObjectArgs.builder() .bucket(config.getBucket()) // bucket 必须传递 .object(path) // 相对路径作为 key .build()); &#125; @Override public byte[] getContent(String path) throws Exception &#123; GetObjectResponse response = client.getObject(GetObjectArgs.builder() .bucket(config.getBucket()) // bucket 必须传递 .object(path) // 相对路径作为 key .build()); return IoUtil.readBytes(response); &#125;&#125; S3 文件客户端的配置类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576package common.file.core.client.s3;import cn.hutool.core.util.StrUtil;import com.fasterxml.jackson.annotation.JsonIgnore;import common.file.core.client.FileClientConfig;import lombok.Data;import org.hibernate.validator.constraints.URL;import javax.validation.constraints.AssertTrue;import javax.validation.constraints.NotNull;/** * S3 文件客户端的配置类 */@Datapublic class S3FileClientConfig implements FileClientConfig &#123; public static final String ENDPOINT_QINIU = &quot;qiniucs.com&quot;; public static final String ENDPOINT_ALIYUN = &quot;aliyuncs.com&quot;; public static final String ENDPOINT_TENCENT = &quot;myqcloud.com&quot;; /** * 节点地址 * 1. MinIO：https://www.iocoder.cn/Spring-Boot/MinIO 。例如说，http://127.0.0.1:9000 * 2. 阿里云：https://help.aliyun.com/document_detail/31837.html * 3. 腾讯云：https://cloud.tencent.com/document/product/436/6224 * 4. 七牛云：https://developer.qiniu.com/kodo/4088/s3-access-domainname * 5. 华为云：https://developer.huaweicloud.com/endpoint?OBS */ @NotNull(message = &quot;endpoint 不能为空&quot;) private String endpoint; /** * 自定义域名 * 1. MinIO：通过 Nginx 配置 * 2. 阿里云：https://help.aliyun.com/document_detail/31836.html * 3. 腾讯云：https://cloud.tencent.com/document/product/436/11142 * 4. 七牛云：https://developer.qiniu.com/kodo/8556/set-the-custom-source-domain-name * 5. 华为云：https://support.huaweicloud.com/usermanual-obs/obs_03_0032.html */ @URL(message = &quot;domain 必须是 URL 格式&quot;) private String domain; /** * 存储 Bucket */ @NotNull(message = &quot;bucket 不能为空&quot;) private String bucket; /** * 访问 Key * 1. MinIO：https://www.iocoder.cn/Spring-Boot/MinIO * 2. 阿里云：https://ram.console.aliyun.com/manage/ak * 3. 腾讯云：https://console.cloud.tencent.com/cam/capi * 4. 七牛云：https://portal.qiniu.com/user/key * 5. 华为云：https://support.huaweicloud.com/qs-obs/obs_qs_0005.html */ @NotNull(message = &quot;accessKey 不能为空&quot;) private String accessKey; /** * 访问 Secret */ @NotNull(message = &quot;accessSecret 不能为空&quot;) private String accessSecret; @SuppressWarnings(&quot;RedundantIfStatement&quot;) @AssertTrue(message = &quot;domain 不能为空&quot;) @JsonIgnore public boolean isDomainValid() &#123; // 如果是七牛，必须带有 domain if (StrUtil.contains(endpoint, ENDPOINT_QINIU) &amp;&amp; StrUtil.isEmpty(domain)) &#123; return false; &#125; return true; &#125;&#125; 上传文件工具文件上传连接工具123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275package common.file.core.utils;import cn.hutool.core.io.IoUtil;import cn.hutool.core.lang.Assert;import cn.hutool.core.util.StrUtil;import common.file.config.FileConfigConfiguration;import common.file.config.FileConfigDTO;import common.file.core.client.FileClient;import common.file.core.client.FileClientFactory;import lombok.SneakyThrows;import lombok.extern.slf4j.Slf4j;import org.springframework.stereotype.Service;import javax.annotation.PostConstruct;import javax.annotation.Resource;import java.io.InputStream;import java.util.List;/** * @author cjb * @date 2023/5/9 10:17 * @describe 文件上传连接工具 */@Slf4j@Servicepublic class FileClientUtils &#123; /** * Master FileClient 对象，有且仅有一个 */ private FileClient masterFileClient; private static FileClientUtils fileClientUtils; @Resource private FileClientFactory fileClientFactory; @Resource private FileConfigConfiguration fileConfigConfiguration; @PostConstruct public void init() &#123; // 获取所有配置 List&lt;FileConfigDTO&gt; configs = fileConfigConfiguration.getFileConfList(); // 加载所有配置 // 第二步：构建缓存：创建或更新文件 Client configs.forEach(config -&gt; &#123; fileClientFactory.createOrUpdateFileClient(config.getName(), config.getStorage(), config.getConfig()); // 如果是 master，进行设置 if (Boolean.TRUE.equals(config.getMaster())) &#123; masterFileClient = fileClientFactory.getFileClient(config.getName()); &#125; &#125;); log.info(&quot;[initLocalCache][缓存文件配置，数量为:&#123;&#125;]&quot;, configs.size()); // 初始化静态工具 fileClientUtils = this; fileClientUtils.fileClientFactory = this.fileClientFactory; fileClientUtils.fileConfigConfiguration = this.fileConfigConfiguration; &#125; /** * 获得 Master 文件客户端 * * @return 文件客户端 */ public static FileClient getMasterFileClient() &#123; return fileClientUtils.masterFileClient; &#125; /** * 获得指定编号的文件客户端 * * @param confKey 配置编号 * @return 链接对象 */ public static FileClient getFileClient(String confKey) &#123; return fileClientUtils.fileClientFactory.getFileClient(confKey); &#125; /** * 上传文件 * @param inputStream 文件流 * @return */ public static String uploadFile(InputStream inputStream) &#123; return uploadFile(IoUtil.readBytes(inputStream)); &#125; /** * 上传文件返回文件路径 * * @param name 文件名称 * @param inputStream 文件流 * @return */ public static String uploadFile(String name,InputStream inputStream) &#123; return uploadFile(name, IoUtil.readBytes(inputStream)); &#125; /** * 上传文件 * @param content 文件byte * @return */ public static String uploadFile(byte[] content) &#123; return uploadFile(null, null, content); &#125; /** * 上传文件返回文件路径 * * @param name 文件名称 * @param content 文件字节对象 * @return */ public static String uploadFile(String name,byte[] content) &#123; return uploadFile(name,null, content); &#125; /** * 上传文件 * @param name 文件名称 * @param content 文件byte * @param confKey 链接配置key * @return */ public static String uploadFile(String name,byte[] content,String confKey) &#123; return uploadFile(name, null, content,confKey); &#125; /** * 上传文件 * @param content 文件byte * @param confKey 链接配置key * @return */ public static String uploadFile(byte[] content,String confKey) &#123; return uploadFile(null, null, content,confKey); &#125; /** * 上传文件返回文件路径 * * @param name 文件名称 * @param path 文件存储路径 * @param inputStream 文件输入流 * @return */ public static String uploadFile(String name, String path, InputStream inputStream) &#123; return uploadFile(name, path, IoUtil.readBytes(inputStream)); &#125; /** * 上传文件返回文件路径 * * @param name 文件名称 * @param path 文件存储路径 * @param inputStream 文件输入流 * @param confKey 链接对象配置key * @return */ public static String uploadFile(String name, String path, InputStream inputStream, String confKey) &#123; FileClient fileClient = getFileClient(confKey); return uploadFile(name, path, IoUtil.readBytes(inputStream), fileClient); &#125; public static String uploadFile(String name, String path, byte[] content, String confKey) &#123; FileClient fileClient = getFileClient(confKey); return uploadFile(name, path, content, fileClient); &#125; /** * 上传文件返回文件路径 * * @param name 文件名称 * @param path 文件存储路径 * @param content 文件字节对象 * @return */ @SneakyThrows public static String uploadFile(String name, String path, byte[] content) &#123; // 计算默认的 path 名 String type = FileTypeUtils.getMineType(content, name); if (StrUtil.isEmpty(path)) &#123; path = FileUtils.generatePath(content, name); &#125; FileClient client = getMasterFileClient(); Assert.notNull(client, &quot;客户端(master) 不能为空&quot;); return client.upload(content, path, type); &#125; /** * 上传文件返回文件路径 * * @param name 文件名称 * @param path 文件存储路径 * @param content 文件字节对象 * @param client 指定链接对象 * @return */ @SneakyThrows public static String uploadFile(String name, String path, byte[] content, FileClient client) &#123; // 计算默认的 path 名 String type = FileTypeUtils.getMineType(content, name); if (StrUtil.isEmpty(path)) &#123; path = FileUtils.generatePath(content, name); &#125; Assert.notNull(client, &quot;客户端(&#123;&#125;) 不能为空&quot;, client.getConfKey()); return client.upload(content, path, type); &#125; /** * 删除文件 * * @param path 文件路径 * @return */ @SneakyThrows public static void deleteFile(String path) &#123; FileClient client = getMasterFileClient(); Assert.notNull(client, &quot;客户端(master) 不能为空&quot;); client.delete(path); &#125; /** * 删除文件 * * @param path 文件路径 * @param confKey 链接配置key * @return */ @SneakyThrows public static void deleteFile(String path, String confKey) &#123; FileClient client = getFileClient(confKey); Assert.notNull(client, &quot;客户端(&#123;&#125;) 不能为空&quot;, client.getConfKey()); client.delete(path); &#125; /** * 下载文件 * * @param path 文件路径 * @return */ @SneakyThrows public static byte[] getFileContent(String path) &#123; FileClient client = getMasterFileClient(); Assert.notNull(client, &quot;客户端(master) 不能为空&quot;); return client.getContent(path); &#125; /** * 下载文件 * * @param path 文件路径 * @return */ @SneakyThrows public static byte[] getFileContent(String path, String confKey) &#123; FileClient client = getFileClient(confKey); Assert.notNull(client, &quot;客户端(&#123;&#125;) 不能为空&quot;, client.getConfKey()); return client.getContent(path); &#125;&#125; 文件类型工具123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475package common.file.core.utils;import cn.hutool.core.util.StrUtil;import com.alibaba.ttl.TransmittableThreadLocal;import lombok.SneakyThrows;import org.apache.tika.Tika;/** * 文件类型 Utils * * @author */public class FileTypeUtils &#123; private static final ThreadLocal&lt;Tika&gt; TIKA = TransmittableThreadLocal.withInitial(Tika::new); /** * 获得文件的 mineType，对于doc，jar等文件会有误差 * * @param data 文件内容 * @return mineType 无法识别时会返回“application/octet-stream” */ @SneakyThrows public static String getMineType(byte[] data) &#123; return TIKA.get().detect(data); &#125; /** * 已知文件名，获取文件类型，在某些情况下比通过字节数组准确，例如使用jar文件时，通过名字更为准确 * * @param name 文件名 * @return mineType 无法识别时会返回“application/octet-stream” */ public static String getMineType(String name) &#123; return TIKA.get().detect(name); &#125; /** * 在拥有文件和数据的情况下，最好使用此方法，最为准确 * * @param data 文件内容 * @param name 文件名 * @return mineType 无法识别时会返回“application/octet-stream” */ public static String getMineType(byte[] data, String name) &#123; return TIKA.get().detect(data, name); &#125; /** * 判断文件类型是否为视屏 * * @param mineType 文件类型 * @return */ public static boolean isVideo(String mineType) &#123; if (StrUtil.startWith(mineType, &quot;video&quot;)) &#123; return true; &#125; return false; &#125; /** * 判断文件类型是否为图片 * * @param mineType 文件类型 * @return */ public static boolean isImage(String mineType) &#123; if (StrUtil.startWith(mineType, &quot;image&quot;)) &#123; return true; &#125; return false; &#125;&#125; 文件工具类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283package common.file.core.utils;import cn.hutool.core.io.FileTypeUtil;import cn.hutool.core.io.FileUtil;import cn.hutool.core.io.file.FileNameUtil;import cn.hutool.core.util.IdUtil;import cn.hutool.core.util.StrUtil;import cn.hutool.crypto.digest.DigestUtil;import lombok.SneakyThrows;import java.io.ByteArrayInputStream;import java.io.File;/** * 文件工具类 */public class FileUtils &#123; /** * 创建临时文件 * 该文件会在 JVM 退出时，进行删除 * * @param data 文件内容 * @return 文件 */ @SneakyThrows public static File createTempFile(String data) &#123; File file = createTempFile(); // 写入内容 FileUtil.writeUtf8String(data, file); return file; &#125; /** * 创建临时文件 * 该文件会在 JVM 退出时，进行删除 * * @param data 文件内容 * @return 文件 */ @SneakyThrows public static File createTempFile(byte[] data) &#123; File file = createTempFile(); // 写入内容 FileUtil.writeBytes(data, file); return file; &#125; /** * 创建临时文件，无内容 * 该文件会在 JVM 退出时，进行删除 * * @return 文件 */ @SneakyThrows public static File createTempFile() &#123; // 创建文件，通过 UUID 保证唯一 File file = File.createTempFile(IdUtil.simpleUUID(), null); // 标记 JVM 退出时，自动删除 file.deleteOnExit(); return file; &#125; /** * 生成文件路径 * * @param content 文件内容 * @param originalName 原始文件名 * @return path，唯一不可重复 */ public static String generatePath(byte[] content, String originalName) &#123; String sha256Hex = DigestUtil.sha256Hex(content); // 情况一：如果存在 name，则优先使用 name 的后缀 if (StrUtil.isNotBlank(originalName)) &#123; String extName = FileNameUtil.extName(originalName); return StrUtil.isBlank(extName) ? sha256Hex : sha256Hex + &quot;.&quot; + extName; &#125; // 情况二：基于 content 计算 return sha256Hex + &#x27;.&#x27; + FileTypeUtil.getType(new ByteArrayInputStream(content)); &#125;&#125; 上传测试类FTP 上传测试12345678910111213141516171819202122232425262728293031323334353637383940package common.file.core.client.ftp;import cn.hutool.core.io.resource.ResourceUtil;import cn.hutool.core.util.IdUtil;import cn.hutool.extra.ftp.FtpMode;import org.junit.jupiter.api.Disabled;import org.junit.jupiter.api.Test;public class FtpFileClientTest &#123; @Test @Disabled public void test() &#123; // 创建客户端 FtpFileClientConfig config = new FtpFileClientConfig(); config.setDomain(&quot;http://127.0.0.1:48080&quot;); config.setBasePath(&quot;/home/ftp&quot;); config.setHost(&quot;kanchai.club&quot;); config.setPort(221); config.setUsername(&quot;&quot;); config.setPassword(&quot;&quot;); config.setMode(FtpMode.Passive.name()); FtpFileClient client = new FtpFileClient(&quot;0L&quot;, config); client.init(); // 上传文件 String path = IdUtil.fastSimpleUUID() + &quot;.jpg&quot;; byte[] content = ResourceUtil.readBytes(&quot;file/erweima.jpg&quot;); String fullPath = client.upload(content, path, &quot;image/jpeg&quot;); System.out.println(&quot;访问地址：&quot; + fullPath); if (false) &#123; byte[] bytes = client.getContent(path); System.out.println(&quot;文件内容：&quot; + bytes); &#125; if (false) &#123; client.delete(path); &#125; &#125;&#125; local上传测试12345678910111213141516171819202122232425262728package common.file.core.client.local;import cn.hutool.core.io.resource.ResourceUtil;import cn.hutool.core.util.IdUtil;import org.junit.jupiter.api.Disabled;import org.junit.jupiter.api.Test;public class LocalFileClientTest &#123; @Test @Disabled public void test() &#123; // 创建客户端 LocalFileClientConfig config = new LocalFileClientConfig(); config.setDomain(&quot;http://127.0.0.1:48080&quot;); config.setBasePath(&quot;/Users/test/file_test&quot;); LocalFileClient client = new LocalFileClient(&quot;0L&quot;, config); client.init(); // 上传文件 String path = IdUtil.fastSimpleUUID() + &quot;.jpg&quot;; byte[] content = ResourceUtil.readBytes(&quot;file/erweima.jpg&quot;); String fullPath = client.upload(content, path, &quot;image/jpeg&quot;); System.out.println(&quot;访问地址：&quot; + fullPath); client.delete(path); &#125;&#125; sftp 上传测试1234567891011121314151617181920212223242526272829303132333435363738package common.file.core.client.sftp;import cn.hutool.core.io.resource.ResourceUtil;import cn.hutool.core.util.IdUtil;import org.junit.jupiter.api.Disabled;import org.junit.jupiter.api.Test;public class SftpFileClientTest &#123; @Test @Disabled public void test() &#123; // 创建客户端 SftpFileClientConfig config = new SftpFileClientConfig(); config.setDomain(&quot;http://127.0.0.1:48080&quot;); config.setBasePath(&quot;/home/ftp&quot;); config.setHost(&quot;kanchai.club&quot;); config.setPort(222); config.setUsername(&quot;&quot;); config.setPassword(&quot;&quot;); SftpFileClient client = new SftpFileClient(&quot;0L&quot;, config); client.init(); // 上传文件 String path = IdUtil.fastSimpleUUID() + &quot;.jpg&quot;; byte[] content = ResourceUtil.readBytes(&quot;file/erweima.jpg&quot;); String fullPath = client.upload(content, path, &quot;image/jpeg&quot;); System.out.println(&quot;访问地址：&quot; + fullPath); if (false) &#123; byte[] bytes = client.getContent(path); System.out.println(&quot;文件内容：&quot; + bytes); &#125; if (false) &#123; client.delete(path); &#125; &#125;&#125; s3 上传测试123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115package common.file.core.client.s3;import cn.hutool.core.io.resource.ResourceUtil;import cn.hutool.core.util.IdUtil;import org.junit.jupiter.api.Disabled;import org.junit.jupiter.api.Test;import javax.validation.Validation;public class S3FileClientTest &#123; @Test @Disabled // MinIO，如果要集成测试，可以注释本行 public void testMinIO() throws Exception &#123; S3FileClientConfig config = new S3FileClientConfig(); // 配置成你自己的 config.setAccessKey(&quot;admin&quot;); config.setAccessSecret(&quot;password&quot;); config.setBucket(&quot;test&quot;); config.setDomain(null); // 默认 9000 endpoint config.setEndpoint(&quot;http://127.0.0.1:9000&quot;); // 执行上传 testExecuteUpload(config); &#125; @Test @Disabled // 阿里云 OSS，如果要集成测试，可以注释本行 public void testAliyun() throws Exception &#123; S3FileClientConfig config = new S3FileClientConfig(); // 配置成你自己的 config.setAccessKey(&quot;ALIYUN_ACCESS_KEY&quot;); config.setAccessSecret(&quot;ALIYUN_SECRET_KEY&quot;); config.setBucket(&quot;test&quot;); config.setDomain(&quot;test&quot;); // 如果有自定义域名，则可以设置。http://ali-oss.iocoder.cn // 默认上海的 endpoint config.setEndpoint(&quot;cos.ap-shanghai.myqcloud.com&quot;); // 执行上传 testExecuteUpload(config); &#125; @Test @Disabled // 腾讯云 COS，如果要集成测试，可以注释本行 public void testQCloud() throws Exception &#123; S3FileClientConfig config = new S3FileClientConfig(); // 配置成你自己的 config.setAccessKey(System.getenv(&quot;QCLOUD_ACCESS_KEY&quot;)); config.setAccessSecret(System.getenv(&quot;QCLOUD_SECRET_KEY&quot;)); config.setBucket(&quot;aoteman-1255880240&quot;); config.setDomain(null); // 如果有自定义域名，则可以设置。http://tengxun-oss.iocoder.cn // 默认上海的 endpoint config.setEndpoint(&quot;cos.ap-shanghai.myqcloud.com&quot;); // 执行上传 testExecuteUpload(config); &#125; @Test @Disabled // 七牛云存储，如果要集成测试，可以注释本行 public void testQiniu() throws Exception &#123; S3FileClientConfig config = new S3FileClientConfig(); // 配置成你自己的 config.setAccessKey(System.getenv(&quot;QINIU_ACCESS_KEY&quot;)); config.setAccessSecret(System.getenv(&quot;QINIU_SECRET_KEY&quot;));// config.setAccessKey(&quot;b7yvuhBSAGjmtPhMFcn9iMOxUOY_I06cA_p0ZUx8&quot;);// config.setAccessSecret(&quot;kXM1l5ia1RvSX3QaOEcwI3RLz3Y2rmNszWonKZtP&quot;); config.setBucket(&quot;test&quot;); config.setDomain(&quot;http://test.test.iocoder.cn&quot;); // 如果有自定义域名，则可以设置。 // 默认上海的 endpoint config.setEndpoint(&quot;s3-cn-south-1.qiniucs.com&quot;); // 执行上传 testExecuteUpload(config); &#125; @Test @Disabled // 华为云存储，如果要集成测试，可以注释本行 public void testHuaweiCloud() throws Exception &#123; S3FileClientConfig config = new S3FileClientConfig(); // 配置成你自己的// config.setAccessKey(System.getenv(&quot;HUAWEI_CLOUD_ACCESS_KEY&quot;));// config.setAccessSecret(System.getenv(&quot;HUAWEI_CLOUD_SECRET_KEY&quot;)); config.setBucket(&quot;test&quot;); config.setDomain(null); // 如果有自定义域名，则可以设置。 // 默认上海的 endpoint config.setEndpoint(&quot;obs.cn-east-3.myhuaweicloud.com&quot;); // 执行上传 testExecuteUpload(config); &#125; private void testExecuteUpload(S3FileClientConfig config) throws Exception &#123; // 创建 Client S3FileClient client = new S3FileClient(&quot;test&quot;, config); client.init(); // 上传文件 String path = IdUtil.fastSimpleUUID() + &quot;.png&quot;; byte[] content = ResourceUtil.readBytes(&quot;file/test.png&quot;); String fullPath = client.upload(content, path, &quot;image/png&quot;); System.out.println(&quot;访问地址：&quot; + fullPath); // 读取文件 if (true) &#123; byte[] bytes = client.getContent(path); System.out.println(&quot;文件内容：&quot; + bytes.length); &#125; // 删除文件 if (false) &#123; client.delete(path); &#125; &#125;&#125;"},{"title":"java国际化工具类","path":"/2023/06/03/java国际化工具类/","content":"创建工具类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122import org.apache.commons.lang3.ObjectUtils;import java.util.*;/** * @author cjb * @date 2022/7/22 9:20 * @description 国际化工具类 **/public class I18nUtils &#123; /** * 指向国际化配置资源文件地址 */ private static final String REOURCES_PATH = &quot;i18n/resource&quot;; /** * 可以添加多个地址 */ private static List&lt;String&gt; msgResources = Arrays.asList(REOURCES_PATH); /** * 获取配置文件中指定key和指定环境中的数据 * 如果不传语言环境 则读取默认配置中的数据 * * @param environment 语言 * @param key key * @return 值 */ public static String getString(String environment, String key) &#123; Locale locale = getLocale(environment); return getMessage(key, null, locale); &#125; /** * 获取配置文件中指定key和指定环境中的数据 * 如果不传语言环境 则读取默认配置中的数据 * * @param key key * @param contextMap 上下文 * @return 值 */ public static String getString(String key, Map contextMap) &#123; // 获取请求头中的语言信息,根据业务自己定义 String environment = SecurityUtils.getLanguage(); Locale locale = getLocale(environment); return getMessage(key, contextMap, locale); &#125; public static Locale getLocale(String environment) &#123; Locale locale; if (StringUtils.equalsIgnoreCase(environment, &quot;CN&quot;)) &#123; locale = Locale.CHINA; &#125; else if (StringUtils.equalsIgnoreCase(environment, &quot;EN&quot;)) &#123; locale = Locale.US; &#125; else &#123; locale = Locale.CHINA; &#125; return locale; &#125; public static String getMessage(String msgKey, Map mapParams, Locale locale) &#123; if (StringUtils.isEmpty(msgKey)) &#123; return &quot;&quot;; &#125; if (null == locale) &#123; locale = getLocale(null); &#125; String resultMsg = msgKey; for (String msgResource : msgResources) &#123; ResourceBundle bundle = ResourceBundle.getBundle(msgResource, locale); String result = null; try &#123; result = bundle.getString(msgKey); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; if (StringUtils.isNotBlank(result)) &#123; resultMsg = result; break; &#125; &#125; return replaceParams(resultMsg, mapParams); &#125; /** * 获取配置文件中指定key和指定环境中的数据 * 如果不传语言环境 则读取默认配置中的数据 * * @param key key * @return 值 */ public static String getSystemString(String key) &#123; // 获取请求头中的语言信息,根据业务自己定义 String environment = SecurityUtils.getLanguage(); Locale locale = getLocale(environment); return getMessage(key, null, locale); &#125; /** * 字符串参数替换$&#123;key&#125; * 此处代码可以放到自己的工具类里面 * @param message 字符串 * @param paramMap 参数集合 * @return 字符串 */ public static String replaceParams(String message, Map&lt;String, Object&gt; paramMap) &#123; if (ObjectUtils.isNotEmpty(paramMap)) &#123; for (String key : paramMap.keySet()) &#123; message = StringUtils.replaceAll(message, &quot;$&#123;&quot; + key + &quot;&#125;&quot;, StringUtils.replaceNull(paramMap.get(key))); &#125; &#125; return message; &#125;&#125; 配置资源文件在resources资源文件夹下新建i18n资源文件夹,创建resource_en_US.properties,和resource_zh_CN.properties配置文件,配置文件命名格式:自定义名_语言代码_国别代码.properties语言代码和国别代码可以在java.util.Locale类中查找例如中文: 资源文件命名为:resource_en_US.properties 中文资源文件的中文需要转为unicode再往配置中写入,否则会导致无法解析"},{"title":"FeignConfig调用携带本次请求的请求头信息","path":"/2023/06/03/FeignConfig调用携带本次请求的请求头信息/","content":"创建FeignConfig1234567891011121314151617181920212223242526272829303132333435363738394041import feign.RequestInterceptor;import feign.RequestTemplate;import lombok.extern.slf4j.Slf4j;import org.springframework.web.context.request.RequestContextHolder;import org.springframework.web.context.request.ServletRequestAttributes;import javax.servlet.http.HttpServletRequest;import java.util.Enumeration;/** * 设置Feign调用请求头信息 */@Slf4jpublic class FeignConfig implements RequestInterceptor &#123; @Override public void apply(RequestTemplate requestTemplate) &#123; // try起来防止由于设备上报的信息没有请求头信息导致报错,调用失败 try &#123; // 获取当前请求头信息 ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes(); HttpServletRequest request = attributes.getRequest(); //传递header里面所有内容 Enumeration&lt;String&gt; headerNames = request.getHeaderNames(); if (headerNames != null) &#123; while (headerNames.hasMoreElements()) &#123; String name = headerNames.nextElement(); String values = request.getHeader(name); // 跳过 content-length ,不跳过会导致feign.RetryableException: too many bytes written executing if (name.equals(&quot;content-length&quot;))&#123; continue; &#125; // 设置请求头信息 requestTemplate.header(name, values); &#125; &#125; &#125; catch (Exception e) &#123; log.info(&quot;设备上报调用,无请求头信息&quot;); &#125; &#125;&#125; feign接口处添加注解参数1234@FeignClient(configuration = FeignConfig.class)public interface testService&#123;\t&#125;"},{"title":"FTPS服务器搭建加FTPS进行文件上传","path":"/2023/06/03/FTPS服务器搭建加FTPS进行文件上传/","content":"搭建FTPS服务器获取vsftpd最新的docker镜像1docker pull fauria/vsftpd 启动镜像123456789docker run -d -p 21:21 -p 20:20 -p 21100-21110:21100-21110 \\-v /home/dispatch/test/root:/home/vsftpd/test \\-e FTP_USER=test \\-e FTP_PASS=test \\-e PASV_ADDRESS=服务器对外ip \\-e PASV_MIN_PORT=21100 \\-e PASV_MAX_PORT=21110 \\--name vsftpd \\--restart=always fauria/vsftpd 注意启动挂在文件目录时最下面一层是和用户名一致的 生成SSl证书文件12# 检查是否安装证书生成工具opensslrpm -qa | grep openssl 没有安装的安装一下 1yum install mod_ssl openssl 生成SSL证书文件 123456789#OpenSSL指令注释:#req #是 X.509 Certificate Signing Request （CSR，证书签名请求）管理的一個命令。#x509 #X.509 证书资料管理。#days #定义证书的有效日期。#newkey #指定证书秘钥处理器。#keyout #設定秘钥存储文件。#out #設定证书存储文件，注意证书和秘钥都储存在一個相同的文件openssl req -new -x509 -nodes -out vsftpd.pem -keyout vsftpd.pem -days 3560Generating a 2048 bit RSA private key 需要填写所在国家,城市之类的,看着填就行 进行FTPS的配置由于我这边是安装到docker中的,所以需要将秘钥文件移动到容器中 1docker cp ./vsftpd.pem &#123;容器id&#125;:/etc/vspdfd/ 进入容器到配置目录下 12345678# 进入容器docker exec -it &#123;容器id&#125; /bin/bash# 进入配置目录 cd /etc/vsftpd/# 编辑配置文件vi vsftpd.conf 添加配置 12345rsa_cert_file=/etc/vsftpd/vsftpd.pemrsa_private_key_file=/etc/vsftpd/vsftpd.pemssl_enable=YES#不重用SSL会话，安全配置项(不配置会导致代码连接失败)require_ssl_reuse=NO 配置最好是放在配置文件最上方,不然可能导致启动失败,循环重启 退出容器并且重启 工具连接测试这里我使用的工具是cuteFTP 成功连接 java代码FTPS文件上传工具123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199import cn.hutool.core.io.IORuntimeException;import cn.hutool.core.util.ObjectUtil;import cn.hutool.core.util.StrUtil;import cn.hutool.extra.ftp.Ftp;import cn.hutool.extra.ftp.FtpException;import lombok.extern.slf4j.Slf4j;import org.apache.commons.net.ftp.FTP;import org.apache.commons.net.ftp.FTPClient;import org.apache.commons.net.ftp.FTPReply;import org.apache.commons.net.ftp.FTPSClient;import java.io.File;import java.io.IOException;import java.io.InputStream;/** * @author cjb * @date 2022-04-08 14:15 * @description ftp 文件上传工具 */@Slf4jpublic class FtpUtil &#123; /** 本地字符编码 */ private static String LOCAL_CHARSET = &quot;GBK&quot;; // FTP协议文件名编码为iso-8859-1 private static String SERVER_CHARSET = &quot;ISO-8859-1&quot;; /** * 操作完成后是否返回原目录 */ private static boolean backToPwd = true; /** * 创建ftps连接对象 * @param host * @param port * @param user * @param password * @return */ public static FTPSClient createFTPSConnection(String host, int port, String user, String password)&#123; FTPSClient ftpsClient = new FTPSClient(); try &#123; ftpsClient.connect(host, port); //FTP的用户名和密码 ftpsClient.login(user,password); // 开启服务器对UTF-8的支持，如果服务器支持就用UTF-8编码，否则就使用本地编码（GBK）.// if (FTPReply.isPositiveCompletion(ftpsClient.sendCommand(// &quot;OPTS UTF8&quot;, &quot;ON&quot;))) &#123;// LOCAL_CHARSET = &quot;UTF-8&quot;;// &#125; ftpsClient.setFileType(FTP.BINARY_FILE_TYPE); ftpsClient.setControlEncoding(LOCAL_CHARSET); ftpsClient.execPBSZ(0); ftpsClient.execPROT(&quot;P&quot;); ftpsClient.enterLocalPassiveMode(); &#125; catch (IOException e) &#123; log.error(&quot;ftps连接创建失败&quot;); e.printStackTrace(); return null; &#125; return ftpsClient; &#125; /** * 上传文件 * @param destPath 上传路径 * @param fileName 上传文件名称 * @param fileStream 文件流 * @param client 连接对象 * @return * @throws IORuntimeException */ public static boolean upload(String destPath, String fileName, InputStream fileStream,FTPSClient client) throws IORuntimeException &#123; try &#123; client.setFileType(FTPClient.BINARY_FILE_TYPE); &#125; catch (IOException e) &#123; throw new IORuntimeException(e); &#125; String pwd = null; if (FtpUtil.backToPwd) &#123; pwd = FtpUtil.pwd(client); &#125; if (StrUtil.isNotBlank(destPath)) &#123; FtpUtil.mkDirs(client,destPath); if (false == FtpUtil.isDir(client,destPath)) &#123; throw new FtpException(&quot;Change dir to [&#123;&#125;] error, maybe dir not exist!&quot;, destPath); &#125; &#125; try &#123; return client.storeFile(fileName, fileStream); &#125; catch (IOException e) &#123; throw new IORuntimeException(e); &#125; finally &#123; if (FtpUtil.backToPwd) &#123; FtpUtil.cd(client,pwd); &#125; &#125; &#125; /** * 进入目录 * @param client 连接对象 * @param directory 目录 * @return */ public static boolean cd(FTPSClient client,String directory) &#123; if (StrUtil.isBlank(directory)) &#123; // 当前目录 return true; &#125; try &#123; return client.changeWorkingDirectory(directory); &#125; catch (IOException e) &#123; throw new IORuntimeException(e); &#125; &#125; /** * 创建目录 * @param client 连接对象 * @param dir 文件路径 */ public static void mkDirs(FTPSClient client,String dir) &#123; final String[] dirs = StrUtil.trim(dir).split(&quot;[\\\\\\\\/]+&quot;); final String now = FtpUtil.pwd(client); if (dirs.length &gt; 0 &amp;&amp; StrUtil.isEmpty(dirs[0])) &#123; //首位为空，表示以/开头 FtpUtil.cd(client,StrUtil.SLASH); &#125; for (String s : dirs) &#123; if (StrUtil.isNotEmpty(s)) &#123; boolean exist = true; try &#123; if (false == FtpUtil.cd(client,s)) &#123; exist = false; &#125; &#125; catch (FtpException e) &#123; exist = false; &#125; if (false == exist) &#123; //目录不存在时创建 FtpUtil.mkdir(client,s); FtpUtil.cd(client,s); &#125; &#125; &#125; // 切换回工作目录 FtpUtil.cd(client,now); &#125; /** * 创建目录 * @param client 连接对象 * @param dir 文件夹名称 * @return * @throws IORuntimeException */ public static boolean mkdir(FTPSClient client,String dir) throws IORuntimeException &#123; try &#123; return client.makeDirectory(dir); &#125; catch (IOException e) &#123; throw new IORuntimeException(e); &#125; &#125; /** * 显示当前目录 * @param client 连接对象 * @return */ public static String pwd(FTPSClient client) &#123; try &#123; return client.printWorkingDirectory(); &#125; catch (IOException e) &#123; throw new IORuntimeException(e); &#125; &#125; /** * 判断给定路径是否为目录 * * @param dir 被判断的路径 * @return 是否为目录 * @since 5.7.5 */ public static boolean isDir(FTPSClient client,String dir) &#123; return FtpUtil.cd(client,dir); &#125;&#125;"},{"title":"记录使用spring boot加mapstruct出现的实现类未创建问题","path":"/2023/06/03/记录使用spring-boot加mapstruct出现的实现类未创建问题/","content":"使用mapstruct进行类型类型转换时出现了未找到mapstruct转换接口未找到实现类的异常,代码如下: pom中使用的版本 123456&lt;!--mapstruct对象转换框架--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mapstruct&lt;/groupId&gt; &lt;artifactId&gt;mapstruct&lt;/artifactId&gt; &lt;version&gt;1.4.2.Final&lt;/version&gt; &lt;/dependency&gt; 先后换了几个版本发现还是一样的报错,百度了下,原因是和lombok有关,相互之间存在一定冲突,需要在pom进行关系绑定,代码如下: 1234567891011121314151617181920212223242526272829&lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;annotationProcessorPaths&gt; &lt;path&gt; &lt;groupId&gt;org.mapstruct&lt;/groupId&gt; &lt;artifactId&gt;mapstruct-processor&lt;/artifactId&gt; &lt;version&gt;1.4.2.Final&lt;/version&gt; &lt;/path&gt; &lt;path&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;$&#123;lombok.version&#125;&lt;/version&gt; &lt;/path&gt; &lt;path&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok-mapstruct-binding&lt;/artifactId&gt; &lt;version&gt;0.2.0&lt;/version&gt; &lt;!-- 如果是0.1.0 有可能出现生成了maptruct的实现类，但该类只创建了对象，没有进行赋值 --&gt; &lt;/path&gt; &lt;/annotationProcessorPaths&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; 进行绑定后问题解决"},{"title":"基于spring boot加redis Stream实现一个消息队列","path":"/2023/06/03/基于spring-boot加redis-Stream实现一个消息队列/","content":"消息队列添加消息和消费确认以及删除消息 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * 消息队列添加消息 * @param message 队列存储消息 * @param queueKey 队列 */public void addMessageBlockingQueue(String message,String queueKey)&#123; Record&lt;String,String&gt; record = StreamRecords.objectBacked(message).withStreamKey(queueKey); redisTemplate.opsForStream().add(record);&#125;/** * 消息队列消费确认 * @param queueKey 消息队列key * @param group 分组名称 * @param recordId 消息id * @return 成功或者失败 */public boolean messageQueueConsumptionAck(String queueKey,String group,RecordId recordId)&#123; try &#123; Long result = redisTemplate.opsForStream().acknowledge(queueKey, group, recordId); if (SUCCESS.equals(result)) &#123; return true; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; return false;&#125;/** * 消息队列删除消息 * @param queueKey 消息队列key * @param recordId 消息id * @return */public boolean messageQueueConsumptionDelField(String queueKey, RecordId recordId)&#123; try &#123; Long result = redisTemplate.opsForStream().delete(queueKey, recordId); if (SUCCESS.equals(result)) &#123; return true; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; return false;&#125; 创建消费者监听处理类： 123456789101112131415161718import lombok.extern.slf4j.Slf4j;import org.springframework.data.redis.connection.stream.ObjectRecord;import org.springframework.data.redis.stream.StreamListener;import org.springframework.stereotype.Component;@Slf4j@Component()public class RedisStreamListener implements StreamListener&lt;String, ObjectRecord&lt;String,String&gt;&gt; &#123; @Override public void onMessage(ObjectRecord&lt;String, String&gt; message) &#123; log.info(message.toString()); // 消息消费ack确认 redisService.messageQueueConsumptionAck(&quot;key&quot;, &quot;group&quot;, &quot;recordId&quot;); // 消费完成消息直接删除 redisService.messageQueueConsumptionDelField(&quot;key&quot;, &quot;recordId&quot;); &#125;&#125; 创建消费者监听类的订阅配置： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586import io.lettuce.core.RedisException;import lombok.RequiredArgsConstructor;import lombok.extern.slf4j.Slf4j;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.dao.InvalidDataAccessApiUsageException;import org.springframework.data.redis.RedisSystemException;import org.springframework.data.redis.connection.RedisConnectionFactory;import org.springframework.data.redis.connection.stream.*;import org.springframework.data.redis.core.StringRedisTemplate;import org.springframework.data.redis.stream.StreamListener;import org.springframework.data.redis.stream.StreamMessageListenerContainer;import org.springframework.data.redis.stream.Subscription;import java.time.Duration;import java.util.ArrayList;import java.util.List;import java.util.Objects;@Slf4j@RequiredArgsConstructor@Configurationpublic class Config &#123; private final StringRedisTemplate redisTemplate; private final StreamListener&lt;String, ObjectRecord&lt;String, String&gt;&gt; streamListener; @Bean public Subscription subscription(RedisConnectionFactory factory) &#123; checkGroup(); // 创建Stream消息监听容器配置 StreamMessageListenerContainer.StreamMessageListenerContainerOptions&lt;String, ObjectRecord&lt;String, String&gt;&gt; options = StreamMessageListenerContainer .StreamMessageListenerContainerOptions .builder() // 设置阻塞时间 .pollTimeout(Duration.ofSeconds(1)) // 配置消息类型 .targetType(String.class) .build(); // 创建Stream消息监听容器 StreamMessageListenerContainer&lt;String, ObjectRecord&lt;String, String&gt;&gt; listenerContainer = StreamMessageListenerContainer.create(factory, options); // 设置消费手动提交配置 Subscription subscription = listenerContainer.receive( // 设置消费者分组和名称 Consumer.from(&quot;group&quot;, &quot;consumer-1&quot;), // 设置订阅Stream的key和获取偏移量，以及消费处理类 StreamOffset.create(&quot;key&quot;, ReadOffset.lastConsumed()), streamListener); // 监听容器启动 listenerContainer.start(); return subscription; &#125; /** * 由于订阅需要先有stream，先做下检查 */ private void checkGroup() &#123; // 创建需要校验的分组List List&lt;String&gt; consumers = new ArrayList&lt;&gt;(); consumers.add(&quot;group&quot;); StreamInfo.XInfoGroups infoGroups = null; try &#123; // 获取Stream的所有组信息 infoGroups = redisTemplate.opsForStream().groups(BaseConstant.SEND_MESSAGE_QUEUE_KEY); &#125; catch (RedisSystemException | RedisException | InvalidDataAccessApiUsageException ex) &#123; log.error(&quot;group key not exist or commend error&quot;, ex); &#125; // 遍历校验分组是否存在 for (String consumer : consumers) &#123; boolean consumerExist = false; if (Objects.nonNull(infoGroups)) &#123; if (infoGroups.stream().anyMatch(t -&gt; Objects.equals(consumer, t.groupName()))) &#123; consumerExist = true; &#125; &#125; // 创建不存在的分组 if (!consumerExist) &#123; redisTemplate.opsForStream().createGroup(&quot;key&quot;, consumer); &#125; &#125; &#125;&#125;"},{"title":"spring Cloud Gateway 自定义过滤器时关于lambda写法的疑惑","path":"/2023/06/03/spring-Cloud-Gateway-自定义过滤器时关于lambda写法的疑惑/","content":"浏览之前同事写的自定义过滤器时发现了一个使用lambda写法的代码 不理解(exchange, chain)这两个参数是在哪里定义，找了父类也没有发现对应的变量，进入lambda表达式查看执行类。 也没有发现是哪里来的这两个参数，回到自定义过滤器仔细观察，发现实际调用地点并不是自定义过滤器的位置，过滤器这里是返回了一个GatewayFilter的实体对象，也就是说这个lambda相当于做了一个接口实现类的实体创建逻辑，并将实体返回。跟换为匿名内部类的写法可能更好理解。 理解关键点：这里并没有使用到对象内部方法只是返回了一个对象，这个对象在实际使用调用方法时才会传入exchange, chain这两个参数。"},{"title":"RestTemplate请求403解决记录","path":"/2023/06/03/RestTemplate请求403解决记录/","content":"123456789101112131415161718192021222324252627282930313233343536import com.alibaba.fastjson.JSONObject;import org.springframework.http.*;import org.springframework.http.converter.StringHttpMessageConverter;import org.springframework.web.client.RestTemplate;import org.springframework.web.util.UriComponentsBuilder;import java.net.URI;import java.nio.charset.StandardCharsets;import java.util.HashMap;import java.util.Map;public class test &#123; public void test()&#123; HttpHeaders headers = new HttpHeaders(); // 添加模拟谷歌浏览器头信息 headers.add(&quot;user-agent&quot;, &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.99 Safari/537.36&quot;); HttpEntity&lt;String&gt; httpEntity = new HttpEntity&lt;String&gt;(headers); RestTemplate restTemplate = new RestTemplate(); restTemplate.getMessageConverters().set(1, new StringHttpMessageConverter(StandardCharsets.UTF_8)); Map&lt;String, String&gt; params = new HashMap&lt;&gt;(2); params.put(&quot;TYPE&quot;, &quot;N&quot;); params.put(&quot;WEEK&quot;, &quot;y&quot;); UriComponentsBuilder uriComponentsBuilder = UriComponentsBuilder.fromUriString(&quot;http://timor.tech/api/holiday/year/&quot;); for (Map.Entry&lt;String, String&gt; entry : params.entrySet()) &#123; uriComponentsBuilder.queryParam(entry.getKey(), entry.getValue()); &#125; URI uri = uriComponentsBuilder.build().encode().toUri(); ResponseEntity&lt;String&gt; response = restTemplate.exchange(uri, HttpMethod.GET,httpEntity,String.class); // 数据解析 if (HttpStatus.OK == response.getStatusCode()) &#123; System.out.println(JSONObject.parseObject(response.getBody())); &#125; &#125;&#125;"},{"title":"RedisTemplate根据hash类型中的item模糊查询,然后删除","path":"/2023/06/03/RedisTemplate根据hash类型中的item模糊查询-然后删除/","content":"1234567891011121314151617181920212223242526 /** * 根据hash中的item模糊删除 key的item * @param key key * @param item item */ public static void hRemoveDim(String key, String item)&#123; ArrayList&lt;String&gt; items = new ArrayList&lt;&gt;();// 模糊查询出准确的item redisTemplate.execute(new RedisCallback() &#123; @Override public Object doInRedis(RedisConnection connection) throws DataAccessException &#123; Cursor&lt;Map.Entry&lt;byte[], byte[]&gt;&gt; entryCursor = connection.hScan(key.getBytes(), ScanOptions.scanOptions().match(&quot;*&quot; + item + &quot;*&quot;).count(1000).build()); while(entryCursor.hasNext())&#123; Map.Entry&lt;byte[], byte[]&gt; next = entryCursor.next(); String key = new String(next.getKey()); // 将查询出的item放入list items.add(key); &#125; connection.close(); return null; &#125; &#125;);// 批量删除对应key中的item redisTemplate.opsForHash().delete(key, item) &#125;"},{"title":"一次java.lang.OutOfMemoryError:Metaspace处理","path":"/2023/06/03/一次java-lang-OutOfMemoryError-Metaspace处理/","content":"其实这个问题非常明显就是Metaspace内存不够导致溢出，调整jvm的-XX:MetaspaceSize&#x3D;56m -XX:MaxMetaspaceSize&#x3D;128m元空间大小参数就能解决。但是根据甲方要求，必须要给出明确的解释，排除是否是内存泄露导致的OutOfMemoryError: Metaspac报错。没有办法，甲方爸爸的要求。那就找点证据说明就是内存给小了的问题。 由于之前的容器已经清除，只能在配置一样的环境中分析。首先查看当前jvm Metaspace分配的空间大小。我是通过arthas的jvm命令进行查看的。首先拉去arthas的jar包。 1curl -O https://arthas.aliyun.com/arthas-boot.jar 然后将jar复制到你要查看项目的docker容器中去 1docker cp ./arthas-boot.jar &#123;容器名称或id&#125;:/home/ 进入容器 1docker exec -it &#123;容器名称或id&#125; sh 启动arthas-boot.jar 1java -jar arthas-boot.jar 看到以上证明启动成功 输入jvm查看jvm信息 和启动配置是一致的。(退出arthas最好使用stop，不然在其他docker中启动会监控的依然是这个项目。)arthas文档地址：https://arthas.aliyun.com/doc/install-detail.html 这个工具功能还有很多比如监控代码执行时间等等。 接下来使用jstat查看项目的gc状况在容器中输入jps，然后就可以使用jstat命令查看。输入jstat -gcutil pid查看gc概要信息 列名称 描述 S0 S0(Survivor 0)空间使用百分比(相对于当前容量) S1 S1(Survivor 1)空间使用百分比(相对于当前容量) E Eden空间使用百分比(相对于当前容量) O 老年代空间使用百分比(相对于当前容量) M 元空间(Metaspace)使用百分比(相对于当前容量) CCS CCS空间使用百分比 YGC 新生代GC(Minor GC&#x2F;Young GC)发生的次数 YGCT YGC所消耗的时间, 单位s FGC Full GC发生的次数 FGCT Full GC消耗的时间, 单位s GCT 所有GC消耗的总时间, 单位s 通过上图分析新生代发生了大量的gc，导致老年代数据快速积压，然后发生Full GC。接下来将jvm的加载类使用jmap dump下来到本地分析查看。 1jmap -dump:live,format=b,file=dump.hprof 6 可以看到本地生成了个dump.hprof 文件 将它拉取到本地，使用JProfiler打开JProfiler官网：https://www.ej-technologies.com/products/jprofiler/overview.html 这些类点进去看看是否有大量创建的异常类 发现没有异常创建的类，分析就是单纯的空间给小了。加大元空间容量分配-XX:MetaspaceSize&#x3D;256m -XX:MaxMetaspaceSize&#x3D;512m 再运行2天看看gc状况 发现新生代gc2w多次，Full GC次数为0，gc大部分都发生在新生代。说明配置有效。这是我第一次实战调优，要是哪里有问题请指出，互相学习一下。"},{"title":"kafka查询topic列表,和topic下消息","path":"/2023/06/03/kafka查询topic列表-和topic下消息/","content":"使用Kafka经常碰到需要查看topic是否创建，或是查看topic下的数据。 最开始想直接找可视化工具进行查看就找到了Kafka tool 然后发现链接数据较少的环境确实比较好用，但是如果topic或topic下的数据较多就会直接卡死，导致无法打开。 Kafka tool 的简单使用首先去官网下载 Kafka tool ：https://www.kafkatool.com/ 无脑下一步进行安装。安装完成后进行新建链接操作 因为数据在Kafka都是byte所以要配置byte转string才能更方便的查看 在 tools –&gt; settings –&gt; Topics 然后选中想要查看的topic在properties中配置key和message为string 然后进入topic下的分区进行查看，点击绿色查询按钮即可查看 如果数据量较少可以使用这个工具进行查看，但是数据太多回直接卡死 使用Kafka命令脚本查看由于我们公司Kafka是部署在docker中所以需要先进入Kafka容器，然后进入opt&#x2F;kafka&#x2F;bin&#x2F;目录下，Kafka脚本命令都在这个目录下 查看kafka topic列表1kafka-topics.sh -list --zookeeper zookeeper地址:端口 从头开始查看kafka topic下的数据1kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic topic_name --from-beginning 按照偏移量查看topic下数据1234kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic topic_name --offset latest --partition 0# --offset设置偏移量 latest代表最后 ，可以设置区间，不设置结尾的话默认为查询到latest(最后)# --partition 设置分区 使用偏移量查询时一定要设置分区才能查询 清除Kafka topic下所有消息1kafka-topics.sh --zookeeper zookeeper地址:端口 --delete --topic topic_name 删除所有消息方便从头开始观看topic消息记录"},{"title":"WebMagic的基础使用","path":"/2023/06/03/WebMagic的基础使用/","content":"官方中文文档：http://webmagic.io/安装WebMagic12345678910&lt;dependency&gt; &lt;groupId&gt;us.codecraft&lt;/groupId&gt; &lt;artifactId&gt;webmagic-core&lt;/artifactId&gt; &lt;version&gt;0.7.3&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;us.codecraft&lt;/groupId&gt; &lt;artifactId&gt;webmagic-extension&lt;/artifactId&gt; &lt;version&gt;0.7.3&lt;/version&gt;&lt;/dependency&gt; 编写TestProcessor定制爬虫逻辑1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package test.webmagic.com.test;import us.codecraft.webmagic.Page;import us.codecraft.webmagic.Site;import us.codecraft.webmagic.Spider;import us.codecraft.webmagic.processor.PageProcessor;import java.util.ArrayList;import java.util.List;/** * @title: TestProcessor * @package test.webmagic.com.test * @author: 彬 * @date: 2020/7/27 * @version: v1.0 * @description: */public class TestProcessor implements PageProcessor&#123; private Site site = Site.me().setRetryTimes(3).setSleepTime(100); @Override public void process(Page page) &#123; // 创建list存储爬虫爬取的数据 List&lt;String&gt; list = new ArrayList&lt;&gt;(); // 获取列表长度 //*[@id=&quot;pjax&quot;]/div[3]/div/article[@class=item] 获取div下article标签中所有class为item的数据 int size = page.getHtml().xpath(&quot;//*[@id=\\&quot;pjax\\&quot;]/div[3]/div/article[@class=item]&quot;).all().size(); for (int i = 1; i &lt;= size; i++) &#123; // 爬取文章标题 //*[@id=\\&quot;pjax\\&quot;]/div[3]/div/article[&quot;+i+&quot;]/h2/a/text() 获取article标签中的h2标签下的a标签中的文本内容 String s = page.getHtml().xpath(&quot;//*[@id=\\&quot;pjax\\&quot;]/div[3]/div/article[&quot;+i+&quot;]/h2/a/text()&quot;).toString(); // 存储文章标题 list.add(s); &#125; System.out.println(&quot;------------------------------------------------------------------&quot;); // 设置存储key名称将爬取到的数据放入 page.putField(&quot;list&quot;,list); // 设置继续爬取下一页 //*[@id=&quot;pjax&quot;]/div[3]/div/nav/a[11]/@href 获取下一页按钮中的a标签的链接 page.addTargetRequests(page.getHtml().xpath(&quot;//*[@id=\\&quot;pjax\\&quot;]/div[3]/div/nav/a[11]/@href&quot;).all()); &#125; @Override public Site getSite() &#123; return site; &#125; public static void main(String[] args) &#123; // 创建爬虫 Spider.create(new TestProcessor()) // 设置需要爬取的url .addUrl(&quot;https://88250.b3log.org/?utm_source=hacpai.com&quot;) // 设置使用定制的Pipeline对爬取到的数据进行保存或其他处理 .addPipeline(new TestPipeline()) // 开启5个线程抓取 .thread(5) .run(); &#125;&#125; 编写TestPipeline定制抽取的结果处理类1234567891011121314151617181920212223242526272829303132333435package test.webmagic.com.test;import us.codecraft.webmagic.ResultItems;import us.codecraft.webmagic.Task;import us.codecraft.webmagic.pipeline.Pipeline;import java.util.List;/** * @title: TestPipeline * @package test.webmagic.com.test * @author: 彬 * @date: 2020/7/27 * @version: v1.0 * @description: */public class TestPipeline implements Pipeline &#123; @Override public void process(ResultItems resultItems, Task task) &#123; // 取出TestProcessor中保存的文章标题list List&lt;String&gt; list = resultItems.get(&quot;list&quot;); for (String s : list) &#123; // 打印 System.out.println(s); &#125; System.out.println(&quot;------------一页的文章的所有标题------------&quot;); &#125;&#125; 启动看看效果第一页标题 第二页标题"},{"title":"Nginx配置https访问","path":"/2023/06/03/Nginx配置https访问/","content":"申请SSL证书在ssl证书申请网站申请ssl证书，这里以腾讯云为例 腾讯云证书申请网址：https://console.cloud.tencent.com/ssl 点击申请证书 按照步骤填写完成，进行域名身份验证。我这边选择的手动验证，因为我的域名和服务器都是阿里云上购买的，需要手动验证。 在阿里云配置域名解析 主机记录、记录值、记录类型按照腾讯云给出的值进行填写，然后等待验证通过（10分钟左右） 颁发证书后将文件下载到本地解压 将Nginx中的.crt和.key文件上传到nginx.conf同级目录下 nginx配置证书1234567891011121314151617181920212223242526server &#123;listen 443 ssl;#填写绑定证书的域名server_name cloud.tencent.com; #网站主页路径。此路径仅供参考，具体请您按照实际目录操作。root /var/www/cloud.tencent.com; index index.html index.htm; #证书文件名称ssl_certificate 1_cloud.tencent.com_bundle.crt; #私钥文件名称ssl_certificate_key 2_cloud.tencent.com.key; ssl_session_timeout 5m;ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;ssl_protocols TLSv1 TLSv1.1 TLSv1.2;ssl_prefer_server_ciphers on;location / &#123; index index.html index.htm;&#125;&#125;server &#123;listen 80;#填写绑定证书的域名server_name cloud.tencent.com; #把http的域名请求转成httpsreturn 301 https://$host$request_uri; &#125; 修改完成后重启nginx即可 nginx在docker中的情况停止运行的nginx容器 重新创建容器，将存放证书的文件夹也映射到容器中 12345678910docker run -d \\-p 80:80 \\-p 443:443 \\--name nginx \\--restart always \\--network=host \\-v /usr/local/docker/nginx/www:/usr/share/nginx/html \\-v /usr/local/docker/nginx/conf/nginx.conf:/etc/nginx/nginx.conf \\-v /usr/local/docker/nginx/logs:/var/log/nginx \\-v /usr/local/docker/nginx/conf/zhenshu:/etc/nginx/zhenshu nginx:1.8 在配置nginx.conf中证书路径时添加一层你的文件夹路径 1234#证书文件名称ssl_certificate zhenshu/1_cloud.tencent.com_bundle.crt; #私钥文件名称ssl_certificate_key zhenshu/2_cloud.tencent.com.key; 证书查找路径是从&#x2F;etc&#x2F;nginx&#x2F;路径开始查找的，路径一定不要配错。 中途本来项配置的是相对路径结果，证书查找路径变成了&#x2F;etc&#x2F;nginx&#x2F;..&#x2F;..&#x2F;xxx&#x2F;xxx&#x2F;xx目录，所以文件一定要挂载到&#x2F;etc&#x2F;nginx&#x2F;目录下，不然会找不到的！ 配置完成启动后进入网站查看 https配置完成！"},{"title":"在Spring Boot项目中使用https(jks)","path":"/2023/06/03/在Spring-Boot项目中使用https-jks/","content":"SpringBoot配置HTTPS在工作中时长会遇到配置https，SpringBoot自带的是tomcat服务器一般使用的.jks文件配置SSL加密。 过程中会用到两个工具：OpenSSL，Keytool工具。 OpenSSL：下载地址：http://slproweb.com/products/Win32OpenSSL.html keytool工具，这是jdk自带的工具，在jdk的&#x2F;bin目录下可以找到。 自己生成CSRhttps供应商不会直接提供.jks文件。所以，我们就需要将加密文件转换成所需要的jks文件。 解压已下载的证书压缩包，获得“xxx.pem”文件和xxx.key文件 “server.pem”文件包括两段证书代码“—–BEGIN CERTIFICATE—–”和“—–END CERTIFICATE—–”，分别为服务器证书和中级CA证书。 使用OpenSSL工具，将pem格式证书转换为PFX格式证书，得到“server.pfx”文件。找到openssl的bin目录，找到openssl.exe文件，单击右键以管理员身份运行，打开命令行，输入命令： 1pkcs12 -export -out D:\\xxx.pfx -in D:\\xxx.pem -inkey D:\\xxx.key 按照要求输入两次密码，这时在d盘生成了xxx.pfx文件请牢记此处输入的PFX证书密码。后续设置JKS密码需要与此处设置的PFX密码保持一致，否则可能会导致Tomcat启动失败。 使用Keytool工具，将PFX格式证书文件转换成JKS格式，得到“xxx.jks”文件。1keytool -importkeystore -srckeystore D:\\xxx.pfx -destkeystore D:\\xxx.jks -srcstoretype PKCS12 -deststoretype JKS 按照提示输入2次JKS证书密码 第三次提示输入源密钥库口令：输入生成xxx.pfx中设置PFX证书密码 查看D盘下是否生成 xxx.jks 生成完成后，新建一个“keystorePass.txt”文件，将JKS的密码保存在该文件中。 在SpringBoot中配置将xxx.jks放入resources文件夹下 12345678910#配置jks存放位置server.ssl.key-store=classpath:xxx.jks#https端口号server.port=8090#是否启用SSL证书server.ssl.enabled=true#密钥库密码server.ssl.key-store-password=jks密码#密钥库类型(JKS类型)server.ssl.key-store-type=JKS 启动测试 同时配置http和https都能访问新加配置 12#http端口号http.port=18092 在SpringBoot启动类中添加 12345678910111213141516171819202122// 获取配置端口@Value(&quot;$&#123;http.port&#125;&quot;) private Integer httpPort;@Bean public ServletWebServerFactory servletContainer() &#123; TomcatServletWebServerFactory tomcat = new TomcatServletWebServerFactory(); // 添加http tomcat.addAdditionalTomcatConnectors(createStandardConnector()); return tomcat; &#125;/** * 配置http * * @return connector */ private Connector createStandardConnector() &#123; Connector connector = new Connector(&quot;org.apache.coyote.http11.Http11NioProtocol&quot;); connector.setPort(httpPort); return connector; &#125;"},{"title":"Nginx配置反向代理","path":"/2023/06/03/Nginx配置反向代理/","content":"反向代理后端项目12345678910server &#123; listen 80; server_name www.caojingbin.com; client_max_body_size 20M;\tlocation /aa/ &#123; 拦截路径 proxy_pass http://127.0.0.1:8855/; 代理地址 proxy_set_header Host $host; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; &#125;&#125; 反向代理前端项目，静态项目12345678910111213141516171819server &#123; listen 80; 监听端口 server_name www.baidu.com; 监听ip或域名 client_max_body_size 20M; #配置支持压缩后的静态文件 gzip on; gzip_min_length 1k; gzip_comp_level 9; gzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png; gzip_vary on; gzip_disable &quot;MSIE [1-6]\\.&quot;; #这段不是必须配置，静态资源有gizp文件时配置 location / &#123; 拦截路径 root /usr/share/nginx/html/; 静态资源的路径 index /index.html; 静态资源名称类型 try_files $uri $uri/ /index.html; vue中history模式需要的配置，当前路径的访问转发到，静态资源的路径下的index.html &#125;&#125;"},{"title":"docker安装spring cloud 以及 cloud alibaba 相关支持服务的配置","path":"/2023/06/03/docker安装spring-cloud-以及-cloud-alibaba-相关支持服务的配置/","content":"docker安装与命令使用国内 daocloud 一键安装命令： 1curl -sSL https://get.daocloud.io/docker | sh 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182启动dockersystemctl start docker重启dockersystemctl restart docker停止dockersystemctl stop docker搜索镜像docker search 镜像名称下载镜像docker pull 镜像查看已安装镜像列表docker images删除镜像docker rmi 镜像id运行镜像生成新的容器docker run -d -it 镜像名称:版本号eg: docker run -d -it -p 8080:8080 tomcat:7 -p 端口映射,前者宿主机端口，后者容器端口，多个端口 -p 8080:8080 -p 9090:9090 -d 后台运行容器 -it 以交互模式运行容器 eg: docker run -d -it -p 8080:8080 --name test -v /opt:/opt tomcat:7 -v 数据挂载 -e 设置配置参数 -e TZ=&quot;Asia/Shanghai&quot; 设置时区 --network=host 容器端口映射主机端口 --restart always docker重启时重启容器查看运行容器docker ps查看所有容器docker ps -a进入容器docker exec -it 容器id /bin/bash退出容器不停止容器Ctrl+P+Q退出容器停止容器exit当容器启动时有添加 -d命令同时有进程在前台运行时exit退出时不会停止容器容器的启动停止docker start 容器iddocker stop 容器id重启容器docker restart 容器id删除容器docker rm 容器id查看容器日志docker logs 容器id -f查看指定时间后的日志，只显示最后100行docker logs -f -t --since=&quot;2020-06-17&quot; --tail=100 CONTAINER_ID查看某时间段日志docker logs -t --since=&quot;2020-06-17T13:23:37&quot; --until &quot;2020-06-17T12:23:37&quot; CONTAINER_ID修改已启动的容器的时区1.复制相应的时区文件，替换系统时区文件；cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime有的容器基础镜像是有这个文件的，直接拷贝就可以，如果不能拷贝，则是因为创建镜像时依赖的基础镜像 运行的容器没有这两个文件，使用下面的办法2. 创建文件夹mkdir -p /usr/share/zoneinfo/Asia3.回到宿主机，复制宿主机里的文件到容器中docker cp /usr/share/zoneinfo/Asia/Shanghai 容器ID或容器名:/usr/share/zoneinfo/Asia4. 进入容器docker exec -it 容器Id或容器名 bash执行命令 cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime5. 验证 输入 date docker安装MySQLdocker search mysql 命令来查看可用版本 下载 Mysql 镜像 1docker pull mysql:5.6 部署启动MySQL镜像 123456docker run -d \\--name mysql \\-p 3306:3306 \\-e MYSQL_ROOT_PASSWORD=123456 \\mysql:5.7 -d：以后台的方式运行； –name mysql：指定容器的名称为 mysql; -p 3306:3306 将容器的 3306 端口挂载到宿主机的 3306 端口上； -e MYSQL_ROOT_PASSWORD&#x3D;123456：指定 root 的密码为 123456 将容器中的目录文件复制到宿主机中 1234# 将容器中的 mysql 配置文件复制到宿主机中指定路径下，路径可以根据需要进行修改docker cp mysql:/etc/mysql/mysql.conf.d/mysqld.cnf /usr/local/docker/mysql/config# 将容器中的 mysql 存储目录复制到宿主机中docker cp mysql:/var/lib/mysql/ /usr/local/docker/mysql/data 停止容器并删除 12docker stop 容器id docker rm 容器id 正式运行 Mysql 容器并将刚刚复制到本地的配置和存储目录挂载到新的容器里面 12345678docker run -d \\--name mysql \\-p 3306:3306 \\--restart always \\-v /usr/local/docker/mysql/config/mysqld.cnf:/etc/mysql/mysql.conf.d/mysqld.cnf \\-v /usr/local/docker/mysql/data/mysql:/var/lib/mysql \\-e MYSQL_ROOT_PASSWORD=123456 \\mysql:5.7 完成后可以docker ps查看容器是否运行，确认运行远程连接 docker安装zookeeper下载zookeeper镜像 1docker pull zookeeper 启动容器并添加映射 1docker run -d -p 2181:2181 --name zookeeper01 --restart always 镜像id docker 安装redis12345678docker run -d \\-p 6379:6379 \\--name redis \\--restart always \\-v /usr/local/docker/redis/redis.conf:/etc/redis/redis.conf \\-v /usr/local/docker/redis/data:/data \\redis:alpine \\redis-server --appendonly yes --requirepass &quot;123456&quot; -p 6379:6379: 将容器的 6379 端口映射到宿主机的 6379 端口； –restart always 设置docker重启时自动重启容器 -v &#x2F;usr&#x2F;local&#x2F;docker&#x2F;redis&#x2F;data:&#x2F;data : 将容器中的 &#x2F;data 数据存储目录, 挂载到宿主机中 &#x2F;usr&#x2F;local&#x2F;docker&#x2F;redis&#x2F;data 目录下； -v &#x2F;usr&#x2F;local&#x2F;docker&#x2F;redis&#x2F;redis.conf:&#x2F;etc&#x2F;redis&#x2F;redis.conf ： 将容器中 &#x2F;etc&#x2F;redis&#x2F;redis.conf 配置文件，挂载到宿主机的 &#x2F;usr&#x2F;local&#x2F;docker&#x2F;redis&#x2F;redis.conf 文件上； redis-server –appendonly yes: 在容器执行 redis-server 启动命令，并打开 redis 持久化配置; –requirepass “123456” 设置redis密码 进入redis容器并且连接redis 确认正常运行 1docker exec -it redis redis-cli -h 127.0.0.1 -p 6379 -a password docker 安装RabbitMQ下载镜像 12#指定版本，该版本包含了web控制页面docker pull rabbitmq:management 运行镜像 1234567docker run -d \\--hostname my-rabbit \\--name rabbit \\--restart always \\-e RABBITMQ_DEFAULT_USER=user \\-e RABBITMQ_DEFAULT_PASS=password \\-p 15672:15672 -p 5672:5672 rabbitmq:management 访问管理页面 1http://localhost:15672/ docker安装nginx拉取镜像 1docker pull nginx:1.8 测试启动 1docker run --name nginx-test -p 8081:80 -d nginx 将容器内nginx的配置文件拷贝到本地 1docker cp a2bdd792b474:/etc/nginx/nginx.conf /usr/local/docker/nginx/conf 赋予本地存放nginx配置中的文件夹开放权限 1chmod -R 777 nginx 创建容器启动镜像，将配置等需要修改的文件进行映射 12345678docker run -d \\-p 80:80 \\--name nginx-test-web \\--restart always \\--network=host \\-v /usr/local/docker/nginx/www:/usr/share/nginx/html \\-v /usr/local/docker/nginx/conf/nginx.conf:/etc/nginx/nginx.conf \\-v /usr/local/docker/nginx/logs:/var/log/nginx nginx 创建一个index.html放入www文件夹中，访问部署的地址 docker 安装 zipkin1、拉镜像 1docker pull openzipkin/zipkin 2、运行镜像 1docker run -d --restart always -p 9411:9411 --name zipkin openzipkin/zipkin 3、访问可视化界面 1浏览器访问：http://ip:9411/zipkin/ docker 安装 nacos拉镜像，版本查看：https://github.com/nacos-group/nacos-docker 1docker pull nacos/nacos-server:1.1.4 创建数据目录 1mkdir -p /usr/local/docker/nacos/logs 创建存储nacos配置的数据库 1create database nacos_config nacos初始化sql,需要先创建nacos数据库后，然后执行下面的sql https://github.com/alibaba/nacos/blob/master/config/src/main/resources/META-INF/nacos-db.sql 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202/******************************************//* 数据库全名 = nacos_config *//* 表名称 = config_info *//******************************************/CREATE TABLE `config_info` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#x27;id&#x27;, `data_id` varchar(255) NOT NULL COMMENT &#x27;data_id&#x27;, `group_id` varchar(255) DEFAULT NULL, `content` longtext NOT NULL COMMENT &#x27;content&#x27;, `md5` varchar(32) DEFAULT NULL COMMENT &#x27;md5&#x27;, `gmt_create` datetime NOT NULL DEFAULT &#x27;2010-05-05 00:00:00&#x27; COMMENT &#x27;创建时间&#x27;, `gmt_modified` datetime NOT NULL DEFAULT &#x27;2010-05-05 00:00:00&#x27; COMMENT &#x27;修改时间&#x27;, `src_user` text COMMENT &#x27;source user&#x27;, `src_ip` varchar(20) DEFAULT NULL COMMENT &#x27;source ip&#x27;, `app_name` varchar(128) DEFAULT NULL, `tenant_id` varchar(128) DEFAULT &#x27;&#x27; COMMENT &#x27;租户字段&#x27;, `c_desc` varchar(256) DEFAULT NULL, `c_use` varchar(64) DEFAULT NULL, `effect` varchar(64) DEFAULT NULL, `type` varchar(64) DEFAULT NULL, `c_schema` text, PRIMARY KEY (`id`), UNIQUE KEY `uk_configinfo_datagrouptenant` (`data_id`,`group_id`,`tenant_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=&#x27;config_info&#x27;;/******************************************//* 数据库全名 = nacos_config *//* 表名称 = config_info_aggr *//******************************************/CREATE TABLE `config_info_aggr` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#x27;id&#x27;, `data_id` varchar(255) NOT NULL COMMENT &#x27;data_id&#x27;, `group_id` varchar(255) NOT NULL COMMENT &#x27;group_id&#x27;, `datum_id` varchar(255) NOT NULL COMMENT &#x27;datum_id&#x27;, `content` longtext NOT NULL COMMENT &#x27;内容&#x27;, `gmt_modified` datetime NOT NULL COMMENT &#x27;修改时间&#x27;, `app_name` varchar(128) DEFAULT NULL, `tenant_id` varchar(128) DEFAULT &#x27;&#x27; COMMENT &#x27;租户字段&#x27;, PRIMARY KEY (`id`), UNIQUE KEY `uk_configinfoaggr_datagrouptenantdatum` (`data_id`,`group_id`,`tenant_id`,`datum_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=&#x27;增加租户字段&#x27;;/******************************************//* 数据库全名 = nacos_config *//* 表名称 = config_info_beta *//******************************************/CREATE TABLE `config_info_beta` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#x27;id&#x27;, `data_id` varchar(255) NOT NULL COMMENT &#x27;data_id&#x27;, `group_id` varchar(128) NOT NULL COMMENT &#x27;group_id&#x27;, `app_name` varchar(128) DEFAULT NULL COMMENT &#x27;app_name&#x27;, `content` longtext NOT NULL COMMENT &#x27;content&#x27;, `beta_ips` varchar(1024) DEFAULT NULL COMMENT &#x27;betaIps&#x27;, `md5` varchar(32) DEFAULT NULL COMMENT &#x27;md5&#x27;, `gmt_create` datetime NOT NULL DEFAULT &#x27;2010-05-05 00:00:00&#x27; COMMENT &#x27;创建时间&#x27;, `gmt_modified` datetime NOT NULL DEFAULT &#x27;2010-05-05 00:00:00&#x27; COMMENT &#x27;修改时间&#x27;, `src_user` text COMMENT &#x27;source user&#x27;, `src_ip` varchar(20) DEFAULT NULL COMMENT &#x27;source ip&#x27;, `tenant_id` varchar(128) DEFAULT &#x27;&#x27; COMMENT &#x27;租户字段&#x27;, PRIMARY KEY (`id`), UNIQUE KEY `uk_configinfobeta_datagrouptenant` (`data_id`,`group_id`,`tenant_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=&#x27;config_info_beta&#x27;;/******************************************//* 数据库全名 = nacos_config *//* 表名称 = config_info_tag *//******************************************/CREATE TABLE `config_info_tag` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#x27;id&#x27;, `data_id` varchar(255) NOT NULL COMMENT &#x27;data_id&#x27;, `group_id` varchar(128) NOT NULL COMMENT &#x27;group_id&#x27;, `tenant_id` varchar(128) DEFAULT &#x27;&#x27; COMMENT &#x27;tenant_id&#x27;, `tag_id` varchar(128) NOT NULL COMMENT &#x27;tag_id&#x27;, `app_name` varchar(128) DEFAULT NULL COMMENT &#x27;app_name&#x27;, `content` longtext NOT NULL COMMENT &#x27;content&#x27;, `md5` varchar(32) DEFAULT NULL COMMENT &#x27;md5&#x27;, `gmt_create` datetime NOT NULL DEFAULT &#x27;2010-05-05 00:00:00&#x27; COMMENT &#x27;创建时间&#x27;, `gmt_modified` datetime NOT NULL DEFAULT &#x27;2010-05-05 00:00:00&#x27; COMMENT &#x27;修改时间&#x27;, `src_user` text COMMENT &#x27;source user&#x27;, `src_ip` varchar(20) DEFAULT NULL COMMENT &#x27;source ip&#x27;, PRIMARY KEY (`id`), UNIQUE KEY `uk_configinfotag_datagrouptenanttag` (`data_id`,`group_id`,`tenant_id`,`tag_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=&#x27;config_info_tag&#x27;;/******************************************//* 数据库全名 = nacos_config *//* 表名称 = config_tags_relation *//******************************************/CREATE TABLE `config_tags_relation` ( `id` bigint(20) NOT NULL COMMENT &#x27;id&#x27;, `tag_name` varchar(128) NOT NULL COMMENT &#x27;tag_name&#x27;, `tag_type` varchar(64) DEFAULT NULL COMMENT &#x27;tag_type&#x27;, `data_id` varchar(255) NOT NULL COMMENT &#x27;data_id&#x27;, `group_id` varchar(128) NOT NULL COMMENT &#x27;group_id&#x27;, `tenant_id` varchar(128) DEFAULT &#x27;&#x27; COMMENT &#x27;tenant_id&#x27;, `nid` bigint(20) NOT NULL AUTO_INCREMENT, PRIMARY KEY (`nid`), UNIQUE KEY `uk_configtagrelation_configidtag` (`id`,`tag_name`,`tag_type`), KEY `idx_tenant_id` (`tenant_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=&#x27;config_tag_relation&#x27;;/******************************************//* 数据库全名 = nacos_config *//* 表名称 = group_capacity *//******************************************/CREATE TABLE `group_capacity` ( `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT COMMENT &#x27;主键ID&#x27;, `group_id` varchar(128) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;Group ID，空字符表示整个集群&#x27;, `quota` int(10) unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;配额，0表示使用默认值&#x27;, `usage` int(10) unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;使用量&#x27;, `max_size` int(10) unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;单个配置大小上限，单位为字节，0表示使用默认值&#x27;, `max_aggr_count` int(10) unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;聚合子配置最大个数，，0表示使用默认值&#x27;, `max_aggr_size` int(10) unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;单个聚合数据的子配置大小上限，单位为字节，0表示使用默认值&#x27;, `max_history_count` int(10) unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;最大变更历史数量&#x27;, `gmt_create` datetime NOT NULL DEFAULT &#x27;2010-05-05 00:00:00&#x27; COMMENT &#x27;创建时间&#x27;, `gmt_modified` datetime NOT NULL DEFAULT &#x27;2010-05-05 00:00:00&#x27; COMMENT &#x27;修改时间&#x27;, PRIMARY KEY (`id`), UNIQUE KEY `uk_group_id` (`group_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=&#x27;集群、各Group容量信息表&#x27;;/******************************************//* 数据库全名 = nacos_config *//* 表名称 = his_config_info *//******************************************/CREATE TABLE `his_config_info` ( `id` bigint(64) unsigned NOT NULL, `nid` bigint(20) unsigned NOT NULL AUTO_INCREMENT, `data_id` varchar(255) NOT NULL, `group_id` varchar(128) NOT NULL, `app_name` varchar(128) DEFAULT NULL COMMENT &#x27;app_name&#x27;, `content` longtext NOT NULL, `md5` varchar(32) DEFAULT NULL, `gmt_create` datetime NOT NULL DEFAULT &#x27;2010-05-05 00:00:00&#x27;, `gmt_modified` datetime NOT NULL DEFAULT &#x27;2010-05-05 00:00:00&#x27;, `src_user` text, `src_ip` varchar(20) DEFAULT NULL, `op_type` char(10) DEFAULT NULL, `tenant_id` varchar(128) DEFAULT &#x27;&#x27; COMMENT &#x27;租户字段&#x27;, PRIMARY KEY (`nid`), KEY `idx_gmt_create` (`gmt_create`), KEY `idx_gmt_modified` (`gmt_modified`), KEY `idx_did` (`data_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=&#x27;多租户改造&#x27;;/******************************************//* 数据库全名 = nacos_config *//* 表名称 = tenant_capacity *//******************************************/CREATE TABLE `tenant_capacity` ( `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT COMMENT &#x27;主键ID&#x27;, `tenant_id` varchar(128) NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;Tenant ID&#x27;, `quota` int(10) unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;配额，0表示使用默认值&#x27;, `usage` int(10) unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;使用量&#x27;, `max_size` int(10) unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;单个配置大小上限，单位为字节，0表示使用默认值&#x27;, `max_aggr_count` int(10) unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;聚合子配置最大个数&#x27;, `max_aggr_size` int(10) unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;单个聚合数据的子配置大小上限，单位为字节，0表示使用默认值&#x27;, `max_history_count` int(10) unsigned NOT NULL DEFAULT &#x27;0&#x27; COMMENT &#x27;最大变更历史数量&#x27;, `gmt_create` datetime NOT NULL DEFAULT &#x27;2010-05-05 00:00:00&#x27; COMMENT &#x27;创建时间&#x27;, `gmt_modified` datetime NOT NULL DEFAULT &#x27;2010-05-05 00:00:00&#x27; COMMENT &#x27;修改时间&#x27;, PRIMARY KEY (`id`), UNIQUE KEY `uk_tenant_id` (`tenant_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=&#x27;租户容量信息表&#x27;;CREATE TABLE `tenant_info` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#x27;id&#x27;, `kp` varchar(128) NOT NULL COMMENT &#x27;kp&#x27;, `tenant_id` varchar(128) default &#x27;&#x27; COMMENT &#x27;tenant_id&#x27;, `tenant_name` varchar(128) default &#x27;&#x27; COMMENT &#x27;tenant_name&#x27;, `tenant_desc` varchar(256) DEFAULT NULL COMMENT &#x27;tenant_desc&#x27;, `create_source` varchar(32) DEFAULT NULL COMMENT &#x27;create_source&#x27;, `gmt_create` bigint(20) NOT NULL COMMENT &#x27;创建时间&#x27;, `gmt_modified` bigint(20) NOT NULL COMMENT &#x27;修改时间&#x27;, PRIMARY KEY (`id`), UNIQUE KEY `uk_tenant_info_kptenantid` (`kp`,`tenant_id`), KEY `idx_tenant_id` (`tenant_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=&#x27;tenant_info&#x27;;CREATE TABLE users (\tusername varchar(50) NOT NULL PRIMARY KEY,\tpassword varchar(500) NOT NULL,\tenabled boolean NOT NULL);CREATE TABLE roles (\tusername varchar(50) NOT NULL,\trole varchar(50) NOT NULL,\tconstraint uk_username_role UNIQUE (username,role));CREATE TABLE permissions ( role varchar(50) NOT NULL, resource varchar(512) NOT NULL, action varchar(8) NOT NULL, constraint uk_role_permission UNIQUE (role,resource,action));INSERT INTO users (username, password, enabled) VALUES (&#x27;nacos&#x27;, &#x27;$2a$10$EuWPZHzz32dJN7jexM34MOeYirDdFAZm2kuWj7VEOJhhZkDrxfvUu&#x27;, TRUE);INSERT INTO roles (username, role) VALUES (&#x27;nacos&#x27;, &#x27;ROLE_ADMIN&#x27;); 运行镜像 12345678910111213141516171819202122232425262728293031docker run -d \\-e PREFER_HOST_MODE=ip \\-e MODE=standalone \\-e SPRING_DATASOURCE_PLATFORM=&#123;数据源平台 mysql&#125; \\-e MYSQL_MASTER_SERVICE_HOST=&#123;MYSQL主服务主机ip&#125; \\-e MYSQL_MASTER_SERVICE_PORT=&#123;MYSQL主服务端口&#125; \\-e MYSQL_MASTER_SERVICE_USER=&#123;MYSQL主服务用户名&#125; \\-e MYSQL_MASTER_SERVICE_PASSWORD=&#123;MYSQL主服务密码&#125; \\-e MYSQL_MASTER_SERVICE_DB_NAME=&#123;MYSQL主服务数据库名 nacos_config &#125; \\-e MYSQL_SLAVE_SERVICE_HOST=&#123;MYSQL从服务主机ip&#125; \\-e MYSQL_SLAVE_SERVICE_PORT=&#123;MYSQL从服务端口&#125; \\-v /usr/local/docker/nacos/logs:/home/nacos/logs \\-p 8848:8848 \\--name nacos \\--restart=always acos/nacos-server:1.1.4 访问nacos 1ip:8848/nacos 新增测试配置 查看数据库是否更新数据库配置没有问题的话可以在表config_info中看到刚才新增的配置信息 获取配置http://ip:8848/nacos/v1/cs/configs?dataId=test01.yml&amp;group=DEFAULT_GROUP docker 安装sentinel拉取镜像 1docker pull bladex/sentinel-dashboard 运行镜像 1docker run --name sentinel -d -p 8858:8858 -d bladex/sentinel-dashboard 访问dashboard 地址 1234567891011地址：http://localhost:8858账号密码都为：sentineldocker 直接拉取镜像无法运行时修改dashboard 的账号密码如果想要修改需要拉取java环境镜像用户可以通过如下参数进行配置：-Dsentinel.dashboard.auth.username=sentinel 用于指定控制台的登录用户名为 sentinel；-Dsentinel.dashboard.auth.password=123456 用于指定控制台的登录密码为 123456；其他参数配置见官网文档https://github.com/alibaba/Sentinel/wiki/%E6%8E%A7%E5%88%B6%E5%8F%B0#%E9%89%B4%E6%9D%83 docker安装 seata:1.0.0拉取镜像 1docker pull seataio/seata-server 测试启动镜像 1docker run --name seata-server -p 8091:8091 -d seataio/seata-server:1.0.0 将容器中的registry.conf复制到本地来 1docker cp seata-server:/seata-server/resources/registry.conf /usr/local/docker/seata/conf 官网下载复制config.txt文件进行修改 12345678910官网地址https://github.com/seata/seata/tree/1.0.0/script/config-center将配置中的store.db.db-type=mysqlstore.db.driver-class-name=com.mysql.jdbc.Driverstore.db.url=jdbc:mysql://127.0.0.1:3306/seata?useUnicode=truestore.db.user=mysqlstore.db.password=mysql改为自己数据库的地址 从官网拉取shell脚本将config.txt推送到nacos配置中心 1234567官网链接：https://github.com/seata/seata/blob/1.0.0/script/config-center/nacos/nacos-config.sh官网shell中推送脚本中有个nacos-config.log这个文件没有导致一直推送报错官网中也未找到nacos-config.log这个文件，自己新建空白nacos-config.log也无法正常运行nacos-config.sh重新拉取#1842标签版本的nacos-config.sh成功执行官网链接：https://github.com/seata/seata/commit/4695d450a07b0f6cdfe61b6dd2db22adbee18969#diff-19562cc9801112787601930e539d9560 这时进入nacos控制台中应该可以看见我们推送过去的配置，默认配置是在public中的，手动克隆到自己建的命名空间 更改复制出来的registry.conf配置文件使用nacos 做注册、配置中心，db存储日志 123456789101112131415161718192021registry &#123; # file 、nacos 、eureka、redis、zk、consul、etcd3、sofa type = &quot;nacos&quot; nacos &#123; serverAddr = &quot;localhost:8848&quot; namespace = &quot;19de1733-6c9f-42b8-9b34-166a9182988f&quot; #上面nacos中的命名空间 cluster = &quot;default&quot; &#125;&#125;config &#123; # file、nacos 、apollo、zk、consul、etcd3 type = &quot;nacos&quot; nacos &#123; serverAddr = &quot;127.0.0.1:8848&quot; namespace = &quot;19de1733-6c9f-42b8-9b34-166a9182988f&quot; #上面nacos中的命名空间 group = &quot;SEATA_GROUP&quot; #分组id &#125;&#125; 创建存储seata配置的数据库 1create database seata 初始化seata数据库 12官网地址：https://github.com/seata/seata/blob/1.0.0/script/server/db/mysql.sql复制出来执行就行 创建完成如图 停止并删除之前的容器 12docker stop seata-serverdocker rm seata-server 赋予本地存放seata配置中的文件夹开放权限 1chmod -R 777 seata 重新创建启动容器，并将本地registry.conf挂载到容器中 123456docker run -d \\--name seata-server \\-e SEATA_IP=向注册中心注册时IP \\-p 8091:8091 \\-v /usr/local/docker/seata/conf/registry.conf:/seata-server/resources/registry.conf \\seataio/seata-server:1.0.0 其他环境变量 运行成功后进入nacos控制台查看服务列表，seata服务成功注册 docker运行自己的jar包创建镜像启动容器运行 使用rz命令上传jar到服务器的指定目录（没有此命令的安装一下lrzsz） 使用vim命令创建Dockerfile 文件 然后将下面的内容复制到Dockerfile文件中12345FROM java:8MAINTAINER binADD demo-1.0.0.jar demo.jarEXPOSE 8080ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;demo.jar&quot;] from java:8 拉取一个jdk为1.8的docker 镜像 maintainer 镜像作者名称 demo-1.0.0.jar 上传的jar包名称 demo.jar 将该jar包重新命名的名称，在容器中运行的名称 expose 该容器暴露的端口是多少，就是jar在容器中以多少端口运行 entrypoint 容器启动之后执行的命令，java -jar demo.jar 即启动jar 创建好Dockerfile文件之后，执行命令 构建镜像 最后的 “ . ” 表示 Dockerfile 文件在当前目录下1docker build -t demo . 镜像构建成功，运行容器1docker run -d --name demo -p 8080:8080 demo docker ps 查看容器是否成功启动 运行jdk镜像将存放jar的目录进行挂载 在服务器中拉取jdk8的镜像 构建容器启动 12345678docker run -d \\--restart=always \\-v /usr/local/docker/demo/jar:/jar -v /server/logs/demo:/mnt/logs/demo \\-p 8080:8080 \\--name demo \\java:8 /usr/bin/java -jar \\-Duser.timezone=GMT+08 \\/jar/demo-1.0.0.jar -Duser.timezone 设置时区 java:8 &#x2F;usr&#x2F;bin&#x2F;java -jar 是执行 java jar的命令 &#x2F;jar&#x2F;demo-1.0.jar 是需要运行的jar包的位置在容器中的什么位置，&#x2F;jar 下面"},{"title":"支付宝支付沙箱环境 当面付 扫码支付","path":"/2023/06/03/支付宝支付沙箱环境-当面付-扫码支付/","content":"支付宝支付（沙箱环境）支付宝官方文档：https://opendocs.alipay.com/open/200/105311 开发者中心沙箱环境链接：https://openhome.alipay.com/platform/appDaily.htm?tab=info 按照文档上进行秘钥的生成和公钥的配置之后，引入支付宝的sdk 和freemarker 12345678910111213141516171819202122&lt;dependency&gt; &lt;groupId&gt;com.alipay.sdk&lt;/groupId&gt; &lt;artifactId&gt;alipay-sdk-java&lt;/artifactId&gt; &lt;version&gt;4.8.10.ALL&lt;/version&gt; &lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-freemarker&lt;/artifactId&gt; &lt;version&gt;2.2.0.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; 支付参数类 1234567891011121314151617181920212223public class AlipayVO &#123; /** *商户订单号，需要保证不重复 */ private String outTradeNo; /** *订单金额 */ private String totalAmount; /** *订单标题 */ private String subject; /** *订单描述 */ private String body;&#125; 编写支付接口 1234567891011121314151617181920212223242526@GetMapping(&quot;/alipay&quot;)public void alipay(HttpServletRequest httpRequest, HttpServletResponse httpResponse,AlipayVO alipayVO) throws ServletException, IOException &#123; AlipayClient alipayClient = new DefaultAlipayClient(AlipayConfig.URL, AlipayConfig.APPID, AlipayConfig.RSA_PRIVATE_KEY, AlipayConfig.FORMAT, AlipayConfig.CHARSET, AlipayConfig.ALIPAY_PUBLIC_KEY, AlipayConfig.SIGNTYPE); //获得初始化的AlipayClient AlipayTradePagePayRequest alipayRequest = new AlipayTradePagePayRequest();//创建API对应的request alipayRequest.setReturnUrl(AlipayConfig.RETURN_URL); alipayRequest.setNotifyUrl(AlipayConfig.NOTIFY_URL);//在公共参数中设置回跳和通知地址 Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;out_trade_no&quot;, alipayVO.getOutTradeNo());// 订单号 map.put(&quot;product_code&quot;, &quot;FAST_INSTANT_TRADE_PAY&quot;);// 销售产品码 map.put(&quot;total_amount&quot;, alipayVO.getTotalAmount());// 交易金额,单位:元 map.put(&quot;subject&quot;, alipayVO.getSubject());// 订单标题 map.put(&quot;body&quot;, alipayVO.getBody());// 订单描述 alipayRequest.setBizContent(JSON.toJSONString(map)); String form = &quot;&quot;; try &#123; form = alipayClient.pageExecute(alipayRequest).getBody(); //调用SDK生成表单 &#125; catch (AlipayApiException e) &#123; e.printStackTrace(); &#125; httpResponse.setContentType(&quot;text/html;charset=&quot; + AlipayConfig.CHARSET); httpResponse.getWriter().write(form);//直接将完整的表单html输出到页面 httpResponse.getWriter().flush(); httpResponse.getWriter().close();&#125; 编写个测试页面调用接口 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;!DOCTYPE html&gt;&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;&lt;title id=&quot;_title&quot;&gt;支付测试&lt;/title&gt;&lt;script src=&quot;https://code.highcharts.com.cn/highcharts/highcharts.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://code.highcharts.com.cn/highcharts/highcharts-3d.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://code.highcharts.com.cn/highcharts/modules/exporting.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://code.highcharts.com.cn/highcharts-plugins/highcharts-zh_CN.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://code.highcharts.com.cn/highcharts/modules/oldie.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://code.highcharts.com.cn/highcharts/modules/cylinder.js&quot;&gt;&lt;/script&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;./js/layui/css/layui.css&quot;&gt;&lt;body&gt;&lt;form class=&quot;layui-form&quot; method=&quot;get&quot; action=&quot;alipay&quot;&gt; &lt;!-- 提示：如果你不想用form，你可以换成div等任何一个普通元素 --&gt; &lt;div class=&quot;layui-form-item&quot;&gt; &lt;label class=&quot;layui-form-label&quot;&gt;商户订单号，需要保证不重复&lt;/label&gt; &lt;div class=&quot;layui-input-block&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;outTradeNo&quot; placeholder=&quot;123&quot; autocomplete=&quot;off&quot; class=&quot;layui-input&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;layui-form-item&quot;&gt; &lt;label class=&quot;layui-form-label&quot;&gt;订单金额&lt;/label&gt; &lt;div class=&quot;layui-input-block&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;totalAmount&quot; placeholder=&quot;100&quot; autocomplete=&quot;off&quot; class=&quot;layui-input&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;layui-form-item&quot;&gt; &lt;label class=&quot;layui-form-label&quot;&gt;订单标题&lt;/label&gt; &lt;div class=&quot;layui-input-block&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;subject&quot; placeholder=&quot;一个测试商品&quot; autocomplete=&quot;off&quot; class=&quot;layui-input&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;layui-form-item&quot;&gt; &lt;label class=&quot;layui-form-label&quot;&gt;订单描述&lt;/label&gt; &lt;div class=&quot;layui-input-block&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;body&quot; placeholder=&quot;100&quot; autocomplete=&quot;off&quot; class=&quot;layui-input&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;layui-form-item&quot;&gt; &lt;div class=&quot;layui-input-block&quot;&gt; &lt;button class=&quot;layui-btn&quot; lay-submit lay-filter=&quot;go&quot;&gt;立即提交&lt;/button&gt; &lt;button type=&quot;reset&quot; class=&quot;layui-btn layui-btn-primary&quot;&gt;重置&lt;/button&gt; &lt;/div&gt; &lt;/div&gt;&lt;/form&gt;&lt;script src=&quot;./js/jquery-3.0.0.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;./js/layui/layui.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;./js/template-web.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 编写进入模板的接口 1234@RequestMapping(&quot;/index&quot;) public String index() &#123; return &quot;indelx&quot;; &#125; 访问页面 填写提交"},{"title":"数据库双数据源配置","path":"/2023/06/03/数据库双数据源配置/","content":"数据库双数据源配置配置文件添加2个数据库的配置信息1234567891011121314151617181920212223242526272829#第一数据源spring.datasource.primary.jdbc-url=jdbc:sqlserver://127.0.0.1\\\\FANGRONG:1433;database=dataserverspring.datasource.primary.username=aaaspring.datasource.primary.password=123456spring.datasource.primary.driver-class-name=com.microsoft.sqlserver.jdbc.SQLServerDriverspring.datasource.primary.type=com.zaxxer.hikari.HikariDataSourcespring.datasource.primary.minimum-idle=1spring.datasource.primary.maximum-pool-size=15spring.datasource.primary.auto-commit=truespring.datasource.primary.idle-timeout=60000spring.datasource.primary.pool-name=fang_sqlserverspring.datasource.primary.max-lifetime=1800000spring.datasource.primary.connection-timeout=30000spring.datasource.primary.connection-test-query=SELECT 1#第二数据源spring.datasource.secondary.jdbc-url=jdbc:mysql://127.0.0.1:3306/reptie?zeroDateTimeBehavior=convertToNull&amp;serverTimezone=GMT%2B8&amp;useSSL=false&amp;useUnicode=true&amp;autoReconnect=truespring.datasource.secondary.username=bbbspring.datasource.secondary.password=123456spring.datasource.secondary.driver-class-name=com.mysql.cj.jdbc.Driverspring.datasource.secondary.type=com.zaxxer.hikari.HikariDataSourcespring.datasource.secondary.minimum-idle=1spring.datasource.secondary.maximum-pool-size=15spring.datasource.secondary.auto-commit=truespring.datasource.secondary.idle-timeout=60000spring.datasource.secondary.pool-name=fang_mysqlspring.datasource.secondary.max-lifetime=1800000spring.datasource.secondary.connection-timeout=30000spring.datasource.secondary.connection-test-query=SELECT 1 配置双数据源的配置类第一个 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import com.zaxxer.hikari.HikariDataSource;import org.apache.ibatis.session.SqlSessionFactory;import org.mybatis.spring.SqlSessionFactoryBean;import org.mybatis.spring.SqlSessionTemplate;import org.mybatis.spring.annotation.MapperScan;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.core.io.support.PathMatchingResourcePatternResolver;import javax.sql.DataSource;/** * @author PangG * @MapperScan 扫描mapper所在路径 */@Configuration@MapperScan(basePackages = &quot;cn.mapper.mysql&quot;, sqlSessionFactoryRef = &quot;mysqlSqlSessionFactory&quot;)public class MySqlDataSourceConfig &#123; /** * @Bean 注册Bean对象 * @ConfigurationProperties 读取properties中的配置参数映射成为一个对象 */ @Bean(name = &quot;mysqlDataSource&quot;) @ConfigurationProperties(prefix = &quot;spring.datasource.secondary&quot;) public HikariDataSource getMysqlDateSource() &#123; return new HikariDataSource(); &#125; /** * @param datasource 数据源 * @return SqlSessionFactory */ @Bean(name = &quot;mysqlSqlSessionFactory&quot;) public SqlSessionFactory mysqlSqlSessionFactory(@Qualifier(&quot;mysqlDataSource&quot;) DataSource datasource) throws Exception &#123; SqlSessionFactoryBean bean = new SqlSessionFactoryBean(); bean.setDataSource(datasource); //mybatis扫描xml所在位置 bean.setMapperLocations(new PathMatchingResourcePatternResolver().getResources(&quot;classpath*:mapper/mysql/*.xml&quot;)); return bean.getObject(); &#125; @Bean(&quot;mysqlSessionTemplate&quot;) public SqlSessionTemplate mysqlSqlSessionTemplate(@Qualifier(&quot;mysqlSqlSessionFactory&quot;) SqlSessionFactory sqlSessionFactory) &#123; return new SqlSessionTemplate(sqlSessionFactory); &#125;&#125; 第二个 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import com.zaxxer.hikari.HikariDataSource;import org.apache.ibatis.session.SqlSessionFactory;import org.mybatis.spring.SqlSessionFactoryBean;import org.mybatis.spring.SqlSessionTemplate;import org.mybatis.spring.annotation.MapperScan;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.Primary;import org.springframework.core.io.support.PathMatchingResourcePatternResolver;import javax.sql.DataSource;/** * @author PangG * @MapperScan 扫描mapper所在路径 */@Configuration@MapperScan(basePackages = &quot;mapper.sqlserver&quot;, sqlSessionFactoryRef = &quot;sqlserverSqlSessionFactory&quot;)public class SqlserverDataSourceConfig &#123; /** * @Bean 注册Bean对象 * @Primary 表示默认数据源 * @ConfigurationProperties 读取properties中的配置参数映射成为一个对象 */ @Bean(name = &quot;sqlserverDataSource&quot;) @Primary @ConfigurationProperties(prefix = &quot;spring.datasource.primary&quot;) public HikariDataSource getSqlserverDateSource() &#123; return new HikariDataSource(); &#125; /** * @param datasource 数据源 * @return SqlSessionFactory * @Primary 默认SqlSessionFactory */ @Bean(name = &quot;sqlserverSqlSessionFactory&quot;) @Primary public SqlSessionFactory sqlserverSqlSessionFactory(@Qualifier(&quot;sqlserverDataSource&quot;) DataSource datasource) throws Exception &#123; SqlSessionFactoryBean bean = new SqlSessionFactoryBean(); bean.setDataSource(datasource); //mybatis扫描xml所在位置 bean.setMapperLocations(new PathMatchingResourcePatternResolver().getResources(&quot;classpath*:mapper/sqlserver/*.xml&quot;)); return bean.getObject(); &#125; @Bean(&quot;sqlserverSessionTemplate&quot;) @Primary public SqlSessionTemplate sqlserverSqlSessionTemplate(@Qualifier(&quot;sqlserverSqlSessionFactory&quot;) SqlSessionFactory sqlSessionFactory) &#123; return new SqlSessionTemplate(sqlSessionFactory); &#125;&#125; 注意配置类配置了扫描路径一定要关闭配置文件中的的扫描 #mybatis.mapper-locations&#x3D;classpath:mapper&#x2F;&#x2F;.xml"},{"title":"CountDownLatch线程计数器","path":"/2023/06/03/CountDownLatch线程计数器/","content":"CountDownLatch的使用概念countDownLatch这个类使一个线程等待其他线程各自执行完毕后再执行。 countDownLatch是通过一个计数器来实现的，计数器的初始值是线程的数量。每当一个线程执行完毕后，计数器的值就-1，当计数器的值为0时，表示所有线程都执行完毕，然后在闭锁上等待的线程就可以恢复工作了。 使用场景在一些时候由于数据库连表查询过于缓慢，并且无法在数据库sql层进行优化，这时我们需要在代码中使用线程去分页查询数据，多个线程都执行完毕后将数据封装进一个list再进行返回，这时需要保证所有线程执行完毕后才能返回。 CountDownLatch的使用1234567891011121314151617181920212223242526// 首先创建一个线程计数器 构造参数为线程数量CountDownLatch countDownLatch = new CountDownLatch(3);// 创建一个结果集合List&lt;&gt; list = new ArrayList&lt;&gt;();// 循环分页查询for (int i = 1; i &lt;= 3; i++) &#123; // executorService 是一个线程池对象，这里直接使用了，也可以通过new Thread()&#123; public void run() &#125;.start();匿名内部类方式创建线程 executorService.execute(() -&gt; &#123; // 调用查询 List&lt;&gt; list1 = mapper.find(i * 10, 10); // 将结果添加到集合中 list.addAll(list1); // 执行完毕调用线程计数器-1 方法 countDownLatch.countDown(); &#125;);&#125;try &#123; // 调用await()方法的线程会被挂起，它会等待直到count值为0才继续执行 countDownLatch.await(); System.out.println(&quot;返回数据添加完成&quot;);&#125; catch (Exception e) &#123; e.printStackTrace();&#125; CountDownLatch的所有方法12345678910111213// countDownLatch类中只提供了一个构造器 count为计数值public CountDownLatch(int count)&#123;&#125;;// 调用await()方法的线程会被挂起，它会等待直到count值为0才继续执行public void await() throws InterruptedException &#123;&#125;;// 和await()类似，只不过等待一定的时间后count值还没变为0的话就会继续执行public boolean await(long timeout, TimeUnit unit) throws InterruptedException &#123;&#125;;// 将count值减1public void countDown() &#123;&#125;;// 返回当前计数public long getCount()&#123;&#125;;// 返回计数器标识和当前计数public String toString()&#123;&#125;;"},{"title":"一次MySQL left join 查询过慢的解决过程","path":"/2023/06/03/一次MySQL-left-join-查询过慢的解决过程/","content":"为什么会出现这个问题在工作的过程中要把sql server 数据库中的几个表迁移到MySQL当中，以为数据库的方言和函数不同很多地方需要替换。在替换完成之后发现了一个问题，同样的一句关联查询语句在sql server总只需要0.2秒左右，在MySQL中却需要11秒左右。 MySQL sql123456789101112131415161718192021222324252627282930SELECT\ta.estate_name AS estateName,\ta.location AS estateLocation,\tIFNULL( b.挂牌数量, 0 ) AS numberListed,\tIFNULL( c.成交数量, 0 ) AS tradingVolume FROM\t(\tSELECT CONCAT( IFNULL( estate_name, &#x27;&#x27; ), IFNULL( area_name, &#x27;&#x27; ) ) AS ea, estate_name, MAX( location ) AS location FROM beike_estate GROUP BY estate_name, area_name ) AS a\tLEFT JOIN ( SELECT estate_name, COUNT( estate_name ) AS 挂牌数量 FROM beike_property WHERE estate_name IS NOT NULL GROUP BY estate_name ) AS b ON a.estate_name = b.estate_name\tLEFT JOIN (\tSELECT CONCAT( IFNULL( estate_name, &#x27;&#x27; ), IFNULL( area_name, &#x27;&#x27; ) ) AS ea, COUNT( estate_name ) AS 成交数量 FROM crawler_publish_property WHERE `status` = 1 GROUP BY\testate_name,\tarea_name ) AS c ON a.ea = c.ea sql server sql123456789101112131415161718192021222324252627282930SELECTa.estate_name AS estateName,a.location AS estateLocation,ISNULL( b.挂牌数量, 0 ) AS numberListed,ISNULL( c.成交数量, 0 ) AS tradingVolume FROM\t(\tSELECT ISNULL( estate_name, &#x27;&#x27; ) + ISNULL( area_name, &#x27;&#x27; ) AS ea, estate_name, MAX ( location ) AS location FROM beike_estate GROUP BY estate_name, area_name ) AS a\tLEFT JOIN ( SELECT estate_name, COUNT ( estate_name ) AS 挂牌数量 FROM beike_property WHERE estate_name IS NOT NULL GROUP BY estate_name ) AS b ON a.estate_name = b.estate_name\tLEFT JOIN (\tSELECT ISNULL( estate_name, &#x27;&#x27; ) + ISNULL( area_name, &#x27;&#x27; ) AS ea, COUNT ( estate_name ) AS 成交数量 FROM crawler_publish_property WHERE [status] = 1 GROUP BY estate_name, area_name ) AS c ON a.ea = c.ea 可以看到2句sql除了函数上的区别，其他地方基本没有区别。 为什么使用MySQL lift join 查询速度过慢既然没有区别为什么MySQL执行速度回这么慢呢？ 查询过慢先想到的就是添加索引，但是这句sql是有三张表查询聚合出来的三张临时表关联查询，由于临时表并没有办法创建索引，我先在三张原始表上添加了索引，然后再次执行，速度还是和之前一样还是10多秒，并没有得到优化。使用 EXPLAIN 分析了一下这条sql，果然并没有使用到索引。 既然索引加不了，那就只能寻找其他解决方案了。经过一番百度了解到对于连表MySQL有2中join的算法分别是 Nested Loop Join算法NLJ 算法:将驱动表&#x2F;外部表的结果集作为循环基础数据，然后循环从该结果集每次一条获取数据作为下一个表的过滤条件查询数据，然后合并结果。如果有多表join，则将前面的表的结果集作为循环数据，取到每行再到联接的下一个表中循环匹配，获取结果集返回给客户端。 Block Nested Loop Join算法BNL 算法:将外层循环的行&#x2F;结果集存入join buffer, 内层循环的每一行与整个buffer中的记录做比较，从而减少内层循环的次数。 那么是不是因为lift join语句没有使用 Block Nested Loop算法所以很慢呢使用EXPLAIN分析发现使用的已经是Block Nested Loop算法了，所以也不是这个原因。 经过一番百度我了解到MySQL有一个Join_buffer_size的配置，这个配置是控制MySQ join 查询的缓存区大小的配置，Join_buffer_size的默认配置为128k。那么是不是由于这个缓存区太小导致查询速度过慢呢，我去查询了一下 结果显示缓存区域有256m的内存可供使用，也就说明查询速度慢并不是这个原因导致的。 经过一番百度，发现并不是因为其他原因，就是单纯的MySQL对join的处理效率不行。 解决方案既然在数据库库陈无法进行优化，那么只能在server层进行优化了 既然是lift join那么只需要把左表进行分页查询再使用多个线程去查询，多个线程查询完成后再封装返回。 12345678910111213141516171819202122232425262728public List&lt;BkFindEstateMsgDTO&gt; findEstateMsg()&#123; List&lt;BkFindEstateMsgDTO&gt; list = beiKePropertyMapper.findEstateMsg(); Integer i = beiKePropertyMapper.findEstateCount(); // 先查出总数目 i = (i / 1000) + 1; // 计算需要几个线程 Integer row = 1000; CountDownLatch countDownLatch = new CountDownLatch(i); // 线程计数器 List&lt;BkFindEstateMsgDTO&gt; bkFindEstateMsgDTOS = new ArrayList&lt;&gt;(); for (int j = 0; j &lt; i; j++) &#123; int j1 = j; executorService.execute(() -&gt; &#123; // 多线程同时查询 List&lt;BkFindEstateMsgDTO&gt; list = beiKePropertyMapper.findEstateMsg1(j1*row,row); bkFindEstateMsgDTOS.addAll(list); countDownLatch.countDown(); // 提交计数器 &#125;); &#125;\ttry &#123; countDownLatch.await(); // 所有线程完成提交 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 使用多线程之后只需要2秒左右就可执行完毕。 如果不想线程太多可以将sql拆分为2个lift join的查询语句，使用2个线程同时进行查询，第二条查询语句返回map集合，将需要连表的条件作为key，查询结果作为value，查询出来之后遍历第一个结果集合通过key取出对应的value set到对应的对象当中即可。这样最后的查询结果在6秒左右。 返回指定的列作为map集合的key只需要在dao层接口方法上添加@MapKey(“”)注解即可。"},{"title":"根据一个经纬度查询附近的楼盘信息","path":"/2023/06/03/根据一个经纬度查询附近的楼盘信息/","content":"最近做一个项目，需要查询一个门店3公里范围内的所有楼盘信息 实现原理先算出该点周围的矩形的四个点，然后使用经纬度去直接匹配数据库中的记录。 java代码123456789101112131415161718192021222324252627282930313233343536/** * 根据传入的经纬度和半径范围确定附近的经纬度范围 * * @param longitude 经度 * @param latitude 纬度 * @param distance 距离 多少千米 * @return */ public static Location getNearbyLocation(double longitude, double latitude, double distance) &#123; boolean b = LocationUtil.checkItude(longitude + &quot;&quot;, latitude + &quot;&quot;); if (!b) &#123; return null; &#125; //先计算查询点的经纬度范围 double r = 6371;//地球半径千米 double dlng = 2 * Math.asin(Math.sin(distance / (2 * r)) / Math.cos(latitude * Math.PI / 180)); dlng = dlng * 180 / Math.PI;//角度转为弧度 double dlat = distance / r; dlat = dlat * 180 / Math.PI; double minlat = latitude - dlat; double maxlat = latitude + dlat; double minlng = longitude - dlng; double maxlng = longitude + dlng; Location location = new Location(); location.setLatitude(latitude); location.setLongitude(longitude); location.setMaxLatitude(maxlat + &quot;&quot;); location.setMinLatitude(minlat + &quot;&quot;); location.setMaxLongitude(maxlng + &quot;&quot;); location.setMinLongitude(minlng + &quot;&quot;); return location; &#125; 经纬度格式校验1234567891011121314/** * 经纬度校验 * 经度longitude: (?:[0-9]|[1-9][0-9]|1[0-7][0-9]|180)\\\\.([0-9]&#123;6&#125;) * 纬度latitude： (?:[0-9]|[1-8][0-9]|90)\\\\.([0-9]&#123;6&#125;) * * @return */ public static boolean checkItude(String longitude, String latitude) &#123; String reglo = &quot;((?:[0-9]|[1-9][0-9]|1[0-7][0-9])\\\\.([0-9]&#123;0,6&#125;))|((?:180)\\\\.([0]&#123;0,6&#125;))&quot;; String regla = &quot;((?:[0-9]|[1-8][0-9])\\\\.([0-9]&#123;0,6&#125;))|((?:90)\\\\.([0]&#123;0,6&#125;))&quot;; longitude = longitude.trim(); latitude = latitude.trim(); return longitude.matches(reglo) == true ? latitude.matches(regla) : false; &#125; 求两点之间的距离123456789101112131415161718192021/** * 求两点之间的距离 * @param lng1 A点经度 * @param lat1 A点纬度 * @param lng2 B点经度 * @param lat2 B点纬度 * @return 两点距离 */public static double getDistance(double lng1, double lat1, double lng2, double lat2) &#123; double EARTH_RADIUS = 6371; double radiansAX = Math.toRadians(lng1); // A经弧度 double radiansAY = Math.toRadians(lat1); // A纬弧度 double radiansBX = Math.toRadians(lng2); // B经弧度 double radiansBY = Math.toRadians(lat2); // B纬弧度 // 公式中“cosβ1cosβ2cos（α1-α2）+sinβ1sinβ2”的部分，得到∠AOB的cos值 double cos = Math.cos(radiansAY) * Math.cos(radiansBY) * Math.cos(radiansAX - radiansBX) + Math.sin(radiansAY) * Math.sin(radiansBY); double acos = Math.acos(cos); // 反余弦值 return EARTH_RADIUS * acos; // 最终结果&#125; 拿到4个确定范围的经纬度就可以去数据库查询了，由于数据库经纬度存的是一个字段需要切割下字段（使用的是Mysql），在 原本的条件下拼接上范围条件就完成！ 条件sql1234substring( location, 1, LOCATE ( &#x27;,&#x27;, location ) - 1 ) &gt;= #&#123;minLongitude&#125;AND substring( location, 1, LOCATE ( &#x27;,&#x27;, location ) - 1 ) &lt;= #&#123;maxLongitude&#125;AND substring( location, LOCATE ( &#x27;,&#x27;, location ) + 1, LENGTH ( a.location ) - 1 ) &gt;= #&#123;minLatitude&#125;AND substring( location, LOCATE ( &#x27;,&#x27;, location ) + 1, LENGTH ( a.location ) - 1 ) &lt;= #&#123;maxLatitude&#125; 得到的结果进行比较删除因为得到的结果是个正方形方位内的数据，想要在地图上显示，会发现超过了地图上圆圈外也有数据，这时候就需要再做一下处理。 123456789//判断两点之间的距离是否大于半径，大于的删除for (int i = 0; i &lt; 之前查询结果的len; i++) &#123;\tdouble distance = LocationUtil.getDistance(longitude, latitude, longitude1, latitude1);\tif (distance &gt; kilometer) &#123; list.remove(i); i--; len--;\t&#125;&#125; 处理之后不不会出现全外面数据显示的情况了！"},{"title":"java完成HTML转PDF wkhtmltopdf","path":"/2023/06/03/java完成HTML转PDF-wkhtmltopdf/","content":"为什么使用wkhtmltopdfHTML转PDF的实现方式有很多，但是转换出来的PDF的质量又好有坏。之前试过IText和一些其他的工具，但是不是格式乱了就是由于标签书写不规范（没有结尾标签）导致转换出来的效果都不太满意，最后发现wkhtmltopdf转换格式什么基本没有问题而且使用也是比较简单就使用wkhtmltopdf。 第一步 下载安装官网地址：https://wkhtmltopdf.org/downloads.html 根据自己的系统来选择安装包。 第二步 配置环境变量 安装完成之后找到安装路径，将其配置到环境变量中，方便使用。 配置完成环境变量之后就可以测试一下了。 看看转换效果。 可以看到转换效果是非常不错的。 第三步 代码调用wkhtmltopdf进行转换辅助代码 123456789101112131415161718192021222324252627package fangrong.com.cn.common.utils;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;public class HtmlToPdfInterceptor extends Thread &#123; private InputStream is; public HtmlToPdfInterceptor(InputStream is) &#123; this.is = is; &#125; public void run() &#123; try &#123; InputStreamReader isr = new InputStreamReader(is, &quot;utf-8&quot;); BufferedReader br = new BufferedReader(isr); String line = null; while ((line = br.readLine()) != null) &#123; System.out.println(line.toString()); //输出转换进度等内容 &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 转换代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170package fangrong.com.cn.common.utils;import java.io.File;/** * Input表单或JavaScript脚本支持：--enable-forms，下面这些是网友整理的参数说明 * wkhtmltopdf [OPTIONS]... &lt;input file&gt; [More input files] &lt;output file&gt; * 常规选项 * --allow &lt;path&gt; 允许加载从指定的文件夹中的文件或文件（可重复） * --book* 设置一会打印一本书的时候，通常设置的选项 * --collate 打印多份副本时整理 * --cookie &lt;name&gt; &lt;value&gt; 设置一个额外的cookie（可重复） * --cookie-jar &lt;path&gt; 读取和写入的Cookie，并在提供的cookie jar文件 * --copies &lt;number&gt; 复印打印成pdf文件数（默认为1） * --cover* &lt;url&gt; 使用HTML文件作为封面。它会带页眉和页脚的TOC之前插入 * --custom-header &lt;name&gt; &lt;value&gt; 设置一个附加的HTTP头（可重复） * --debug-javascript 显示的javascript调试输出 * --default-header* 添加一个缺省的头部，与页面的左边的名称，页面数到右边，例如： --header-left &#x27;[webpage]&#x27; --header-right &#x27;[page]/[toPage]&#x27; --header-line * --disable-external-links* 禁止生成链接到远程网页 * --disable-internal-links* 禁止使用本地链接 * --disable-javascript 禁止让网页执行JavaScript * --disable-pdf-compression* 禁止在PDF对象使用无损压缩 * --disable-smart-shrinking* 禁止使用WebKit的智能战略收缩，使像素/ DPI比没有不变 * --disallow-local-file-access 禁止允许转换的本地文件读取其他本地文件，除非explecitily允许用 --allow * --dpi &lt;dpi&gt; 显式更改DPI（这对基于X11的系统没有任何影响） * --enable-plugins 启用已安装的插件（如Flash * --encoding &lt;encoding&gt; 设置默认的文字编码 * --extended-help 显示更广泛的帮助，详细介绍了不常见的命令开关 * --forms* 打开HTML表单字段转换为PDF表单域 * --grayscale PDF格式将在灰阶产生 * --help Display help * --htmldoc 输出程序HTML帮助 * --ignore-load-errors 忽略claimes加载过程中已经遇到了一个错误页面 * --lowquality 产生低品质的PDF/ PS。有用缩小结果文档的空间 * --manpage 输出程序手册页 * --margin-bottom &lt;unitreal&gt; 设置页面下边距 (default 10mm) * --margin-left &lt;unitreal&gt; 将左边页边距 (default 10mm) * --margin-right &lt;unitreal&gt; 设置页面右边距 (default 10mm) * --margin-top &lt;unitreal&gt; 设置页面上边距 (default 10mm) * --minimum-font-size &lt;) * --no-background 不打印背景 * --orientation &lt;orientation&gt; 设置方向为横向或纵向 * --page-height &lt;unitreal&gt; 页面高度 (default unit millimeter) * --page-offset* &lt;offset&gt; 设置起始页码 (default ) * --page-size &lt;size&gt; 设置纸张大小: A4, Letter, etc. * --page-width &lt;unitreal&gt; 页面宽度 (default unit millimeter) * --password &lt;password&gt; HTTP验证密码 * --post &lt;name&gt; &lt;value&gt; Add an additional post field (repeatable) * --post-file &lt;name&gt; &lt;path&gt; Post an aditional file (repeatable) * --print-media-type* 使用的打印介质类型，而不是屏幕 * --proxy &lt;proxy&gt; 使用代理 * --quiet Be less verbose * --read-args-from-stdin 读取标准输入的命令行参数 * --readme 输出程序自述 * --redirect-delay &lt;msec&gt; 等待几毫秒为JS-重定向(default ) * --replace* &lt;name&gt; &lt;value&gt; 替换名称，值的页眉和页脚（可重复） * --stop-slow-scripts 停止运行缓慢的JavaScripts * --title &lt;text&gt; 生成的PDF文件的标题（第一个文档的标题使用，如果没有指定） * --toc* 插入的内容的表中的文件的开头 * --use-xserver* 使用X服务器（一些插件和其他的东西没有X11可能无法正常工作） * --user-style-sheet &lt;url&gt; 指定用户的样式表，加载在每一页中 * --username &lt;username&gt; HTTP认证的用户名 * --version 输出版本信息退出 * --zoom &lt;) * &lt;p&gt; * 页眉和页脚选项 * --header-center* &lt;text&gt; (设置在中心位置的页眉内容) * --header-font-name* &lt;name&gt; (default Arial)(设置页眉的字体名称) * --header-font-size* &lt;size&gt; (设置页眉的字体大小) * --header-html* &lt;url&gt; (添加一个HTML页眉，后面是网址) * --header-left* &lt;text&gt; (左对齐的页眉文本) * --header-line* (显示一条线在页眉下) * --header-right* &lt;text&gt; (右对齐页眉文本) * --header-spacing* &lt;real&gt; (设置页眉和内容的距离，默认0) * --footer-center* &lt;text&gt; (设置在中心位置的页脚内容) * --footer-font-name* &lt;name&gt; (设置页脚的字体名称) * --footer-font-size* &lt;size&gt; (设置页脚的字体大小default ) * --footer-html* &lt;url&gt; (添加一个HTML页脚，后面是网址) * --footer-left* &lt;text&gt; (左对齐的页脚文本) * --footer-line* 显示一条线在页脚内容上) * --footer-right* &lt;text&gt; (右对齐页脚文本) * --footer-spacing* &lt;real&gt; (设置页脚和内容的距离) * &lt;p&gt; * 页脚和页眉 * [page] 由当前正在打印的页的数目代替 * [frompage] 由要打印的第一页的数量取代 * [topage] 由最后一页要打印的数量取代 * [webpage] 通过正在打印的页面的URL替换 * [section] 由当前节的名称替换 * [subsection] 由当前小节的名称替换 * [date] 由当前日期系统的本地格式取代 * [time] 由当前时间，系统的本地格式取代 * &lt;p&gt; * 轮廓选项 * --dump-outline &lt;file&gt; 转储目录到一个文件 * --outline 显示目录（文章中h1，h2来定） * --outline-depth &lt;level&gt; 设置目录的深度（默认为4） * &lt;p&gt; * 表内容选项中 * --toc-depth* &lt;level&gt; Set the depth of the toc (default) * --toc-disable-back-links* Do not link from section header to toc * --toc-disable-links* Do not link from toc to sections * --toc-font-name* &lt;name&gt; Set the font used for the toc (default Arial) * --toc-header-font-name* &lt;name&gt; The font of the toc header (if unset use --toc-font-name) * --toc-header-font-size* &lt;size&gt; The font size of the toc header (default) * --toc-header-text* &lt;text&gt; The header text of the toc (default Table Of Contents) * --toc-l1-font-size* &lt;size&gt; Set the font size on level of the toc (default) * --toc-l1-indentation* &lt;num&gt; Set indentation on level of the toc (default) * --toc-l2-font-size* &lt;size&gt; Set the font size on level of the toc (default) * --toc-l2-indentation* &lt;num&gt; Set indentation on level of the toc (default) * --toc-l3-font-size* &lt;size&gt; Set the font size on level of the toc (default) * --toc-l3-indentation* &lt;num&gt; Set indentation on level of the toc (default) * --toc-l4-font-size* &lt;size&gt; Set the font size on level of the toc (default) * --toc-l4-indentation* &lt;num&gt; Set indentation on level of the toc (default) * --toc-l5-font-size* &lt;size&gt; Set the font size on level of the toc (default) * --toc-l5-indentation* &lt;num&gt; Set indentation on level of the toc (default) * --toc-l6-font-size* &lt;size&gt; Set the font size on level of the toc (default) * --toc-l6-indentation* &lt;num&gt; Set indentation on level of the toc (default) * --toc-l7-font-size* &lt;size&gt; Set the font size on level of the toc (default) * --toc-l7-indentation* &lt;num&gt; Set indentation on level of the toc (default) * --toc-no-dots* Do not use dots, in the toc * ------------------------------------------------------------------------------------------------------------ */public class HtmlToPdf &#123; /** * html转pdf * * @param srcPath html路径，可以是硬盘上的路径，也可以是网络路径 * @param file pdf文件 * @return 转换成功返回true */ public static boolean convert(String srcPath, File file) &#123; File parent = file.getParentFile(); // 如果pdf保存路径不存在，则创建路径 if (!parent.exists()) &#123; parent.mkdirs(); &#125; StringBuilder cmd = new StringBuilder(); String toPdfTool; if (System.getProperty(&quot;os.name&quot;).indexOf(&quot;Windows&quot;) == -1) &#123; // 根据系统 // 非windows 系统 toPdfTool = &quot;/usr/local/bin/wkhtmltopdf&quot;; &#125; else &#123; toPdfTool = &quot;D:/htmlTopdf/wkhtmltopdf/bin/wkhtmltopdf.exe&quot;; &#125;\t// 这里可以拼接页眉页脚等参数 参数详情在上方 cmd.append(toPdfTool); cmd.append(&quot; &quot;); cmd.append(srcPath); cmd.append(&quot; &quot;); cmd.append(file.getAbsolutePath()); boolean result = true; try &#123; Process proc = Runtime.getRuntime().exec(cmd.toString()); HtmlToPdfInterceptor error = new HtmlToPdfInterceptor(proc.getErrorStream()); HtmlToPdfInterceptor output = new HtmlToPdfInterceptor(proc.getInputStream()); error.start(); output.start(); proc.waitFor(); &#125; catch (Exception e) &#123; result = false; e.printStackTrace(); &#125; return result; &#125;&#125; 到此集成完成。 使用过程中碰到的的一些坑这些坑主要是出现在Linux环境下的 乱码问题 一般乱码的主要原因就是因为Linux中没有simsun的字体，将C:\\Windows\\Fonts中的simsun.ttc拷贝到linux服务器&#x2F;usr&#x2F;share&#x2F;fonts&#x2F;目录下,下次再生成pdf就正常了 Docker容器中的java程序无法调用到Linux本地的wkhtmltopdf脚本 需要将本地的文件挂载映射到dockers容器当中"},{"title":"Markdown 编辑器Editor.md简单集成","path":"/2023/06/03/Markdown-编辑器Editor-md简单集成/","content":"既然要集成，第一步就是找到来源，直接到官方网站下载依赖。 官方网站地址：https://pandao.github.io/editor.md/ 下载之后解压下载文件 要是用的依赖基本就是用红框标注出来的，将需要的依赖丢入自己项目中的resources目录下 找到文本输入框的html，开始引入依赖。 12345678// 引入css样式文件&lt;link rel=&quot;stylesheet&quot; href=&quot;/css/editormd.css&quot; /&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;/css/editormd.preview.min.css&quot; /&gt;// 引入js等依赖&lt;script src=&quot;/js/jquery-3.2.1.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;/js/editormd.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;/lib/prettify.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;/lib/marked.min.js&quot;&gt;&lt;/script&gt; 将文本输入框替换为Markdown编辑器 123&lt;div id=&quot;test-editormd&quot;&gt;\t&lt;textarea placeholder=&quot;正文&quot; style=&quot;display:none;&quot;&gt;&lt;/textarea&gt;&lt;/div&gt; 初始化Markdown编辑器的js 12345678910111213141516171819202122&lt;script type=&quot;text/javascript&quot;&gt; var testEditor; $(function () &#123; testEditor = editormd(&quot;test-editormd&quot;, &#123; // test-editormd为之前定义编辑器所在div的id width: &quot;98%&quot;, height: 300, syncScrolling: &quot;single&quot;, path: &quot;/lib/&quot;, //你的path路径（原资源文件中lib包在我们项目中所放的位置） saveHTMLToTextarea: true, emoji: true, taskList: true, tex: true, flowChart: true, tocm: true, sequenceDiagram: true, /* 上传图片配置 */ imageUpload: false, imageFormats: [&quot;jpg&quot;, &quot;jpeg&quot;, &quot;gif&quot;, &quot;png&quot;, &quot;bmp&quot;, &quot;webp&quot;], // 上传图片支持格式 imageUploadURL: &quot;../imageUpload&quot; // 上传图片的路径 &#125;); &#125;);&lt;/script&gt; 以上集成编辑器就完成了，接下来就是讲取出来的数据展示出来。 第一步依旧是引入所需依赖 1234567891011&lt;link rel=&quot;stylesheet&quot; href=&quot;/css/editormd.css&quot; /&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;/css/editormd.preview.min.css&quot; /&gt;&lt;script src=&quot;/js/jquery-3.2.1.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;/lib/marked.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;/lib/prettify.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;/lib/raphael.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;/lib/underscore.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;/lib/sequence-diagram.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;/lib/flowchart.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;/lib/jquery.flowchart.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;/js/editormd.min.js&quot;&gt;&lt;/script&gt; 页面显示的div 123&lt;div id=&quot;test-editormd&quot; &gt; &lt;textarea style=&quot;display:none;&quot;&gt;&lt;/textarea&gt;&lt;/div&gt; 解析的js 12345678910&lt;script type=&quot;text/javascript&quot;&gt; editormd.markdownToHTML(&quot;test-editormd&quot;, &#123; htmlDecode : &quot;style,script,iframe&quot;, emoji : true, taskList : true, tex : true, // 默认不解析 flowChart : true, // 默认不解析 sequenceDiagram : true // 默认不解析 &#125;);&lt;/script&gt; 到此就完成了Markdown 编辑器Editor.md简单集成。"},{"title":"elasticsearchTemplate的聚合查询","path":"/2023/06/03/elasticsearchTemplate的聚合查询/","content":"直接上代码： 1234567891011121314151617181920212223242526// 创建一个查询条件对象BoolQueryBuilder queryBuilder = QueryBuilders.boolQuery();// 拼接查询条件queryBuilder.should(QueryBuilders.termQuery(&quot;字段&quot;, &quot;值&quot;))；// 创建聚合查询条件TermsAggregationBuilder agg = AggregationBuilders.terms(&quot;聚合名称，自定义，取出时会用到&quot;).field(&quot;聚合字段&quot;).size(100)；// size是查询聚合出来的条数// 创建查询对象SearchQuery build = new NativeSearchQueryBuilder() .withQuery(queryBuilder) //添加查询条件 .addAggregation(agg) // 添加聚合条件 .withPageable(PageRequest.of(0, 1)) //符合查询条件的文档分页（不是聚合的分页） .build();// 执行查询AggregatedPage&lt;TestEntity&gt; testEntities = elasticsearchTemplate.queryForPage(build, TestEntity.class);// 取出聚合结果Aggregations entitiesAggregations = testEntities.getAggregations(); Terms terms = (Terms)propertyInfoEntities.getAggregation(&quot;聚合名称，之前自定义的&quot;);// 遍历取出聚合字段列的值，与对应的数量for (Terms.Bucket bucket : terms.getBuckets()) &#123; String keyAsString = bucket.getKeyAsString(); // 聚合字段列的值 long docCount = bucket.getDocCount();// 聚合字段对应的数量 &#125; 多字段聚合： 12345678910111213141516171819202122232425262728293031323334353637// 创建一个查询条件对象BoolQueryBuilder queryBuilder = QueryBuilders.boolQuery();// 拼接查询条件queryBuilder.should(QueryBuilders.termQuery(&quot;字段&quot;, &quot;值&quot;))；// 创建聚合查询条件TermsAggregationBuilder agg1 = AggregationBuilders.terms(&quot;聚合名称2&quot;).field(聚合字段2).size(100)TermsAggregationBuilder agg = AggregationBuilders.terms(&quot;聚合名称1&quot;).field(&quot;聚合字段1&quot;).size(100).subAggregation(agg1)//拼接上上一个聚合条件// 创建查询对象SearchQuery build = new NativeSearchQueryBuilder() .withQuery(queryBuilder) //添加查询条件 .addAggregation(agg) // 添加聚合条件 .withPageable(PageRequest.of(0, 1)) //符合查询条件的文档分页（不是聚合的分页） .build();// 执行查询AggregatedPage&lt;TestEntity&gt; testEntities = elasticsearchTemplate.queryForPage(build, TestEntity.class);// 取出聚合结果Aggregations entitiesAggregations = testEntities.getAggregations(); Terms terms = (Terms)propertyInfoEntities.getAggregation(&quot;聚合名称&quot;);// 遍历最外层的聚合结果for (Terms.Bucket bucket : terms.getBuckets()) &#123; String keyAsString = bucket.getKeyAsString(); // 聚合字段列的名称 long docCount = bucket.getDocCount();// 聚合字段对应的数量 // 获取内部的聚合字段信息 Aggregations aggregations = bucket.getAggregations(); Terms terms2 = aggregations.get(&quot;聚合名称2&quot;);\t// 遍历获取agg1的聚合信息\tfor (Terms.Bucket bucket1 : terms2.getBuckets()) &#123; String keyAsString2 = bucket.getKeyAsString(); // 聚合字段列的名称 long docCount2 = bucket.getDocCount();// 聚合字段对应的数量 &#125; &#125; 多个字段一次性聚合： 123456789101112131415161718192021222324252627282930// 创建一个查询条件对象BoolQueryBuilder queryBuilder = QueryBuilders.boolQuery();// 拼接查询条件queryBuilder.should(QueryBuilders.termQuery(&quot;字段&quot;, &quot;值&quot;))；// 创建聚合查询条件String script = &quot;doc[&#x27;&quot; + 字段1 + &quot;&#x27;].values +&#x27;/&#x27;+ doc[&#x27;&quot; + 字段2 + &quot;&#x27;].values +&#x27;/&#x27;+ doc[&#x27;&quot; + 字段3 + &quot;&#x27;].values&quot;; // 编写script语句Script script1 = new Script(script); // 新建一个script对象TermsAggregationBuilder agg = AggregationBuilders.terms(&quot;聚合名称&quot;).script(script1).size(99999); // 创建一个聚合查询对象SearchQuery build = new NativeSearchQueryBuilder() .withQuery(queryBuilder) //添加查询条件 .addAggregation(agg) // 添加聚合条件 .withPageable(PageRequest.of(0, 1)) //符合查询条件的文档分页（不是聚合的分页） .build();// 执行查询AggregatedPage&lt;TestEntity&gt; testEntities = elasticsearchTemplate.queryForPage(build, TestEntity.class);Terms terms = (Terms) shopDbEntities.getAggregation(&quot;聚合名称&quot;);for (Terms.Bucket bucket : terms.getBuckets()) &#123; // 循环取出聚合的值 String keyAsString = bucket.getKeyAsString(); String[] split = keyAsString.split(&quot;/&quot;); // 切割取出每个字段 System.out.println(&quot;字段1&quot;+split[0]); System.out.println(&quot;字段2&quot;+split[1]); System.out.println(&quot;字段3&quot;+split[2]); &#125; 更多字段聚合按照以上类推，如果实在对于结构不理解可以将查询语句打印出来，将打印语句拿到Kibana之类的查询工具中查询看下结构，或者直接Debug看下数据结构，就比较好理解了"},{"title":"springBoot集成es使用ElasticsearchTemplate执行滚动查询","path":"/2023/06/03/springBoot集成es使用ElasticsearchTemplate执行滚动查询/","content":"使用Elasticsearch查询大量数据时基本的分页查询就会报错，这种情况下可以使用scroll（滚动）查询 直接上代码： 123456789101112131415161718192021222324252627// 创建查询条件对象BoolQueryBuilder queryBuilder = QueryBuilders.boolQuery();// 拼接查询条件queryBuilder.must(QueryBuilders.termQuery(&quot;status&quot;, 1)); 假设查询状态为1的// 创建查询对象SearchQuery searchQuery = new NativeSearchQueryBuilder() .withIndices(&quot;test_index&quot;)//索引名 .withTypes(&quot;test&quot;)//类型名 .withQuery(queryBuilder)// 查询条件对象 .withPageable(PageRequest.of(0, 1000))//从0页开始查，每页1000个结果 .build();// 滚动查询ScrolledPage&lt;TestEntity&gt; scroll = (ScrolledPage&lt;TestEntity&gt;) elasticsearchTemplate.startScroll(3000, searchQuery, TestEntity.class);// 判断是否有内容while (scroll.hasContent()) &#123;\tList&lt;TestEntity&gt; content = scroll.getContent();\t// 业务逻辑省略\t//取下一页，scrollId在es服务器上可能会发生变化，需要用最新的。发起continueScroll请求会重新刷新快照保留时间\tscroll = (ScrolledPage&lt;TestEntity&gt;) elasticsearchTemplate.continueScroll(scroll.getScrollId(), 3000, EstateInfoEntity.class);&#125;// 最后释放查询elasticsearchTemplate.clearScroll(scroll.getScrollId());"},{"title":"java集成小米推送服务","path":"/2023/06/03/java集成小米推送服务/","content":"集成小米推送服务这类推送一般官方文档都比较详细，如果想要更加详细的了解建议查看官方文档 官方文档地址：https://dev.mi.com/console/appservice/push.html 在正式开发前需要做一些准备 1、开发者需要登录开发者网站进入推送服务(申请AppID, AppKey, AppSecret) 2、访问开发者网站下载SDK； 将下载的SDK解压，将文件夹中的2个依赖jar包丢入项目工程的libs目录 接下来就是发送消息了 1234567891011121314151617181920212223// 正式环境下使用Push服务，启动时需要调用如下代码Constants.useOfficial(); // 测试环境下使用Push服务，启动时需要调用如下代码// Constants.useSandbox(); Sender sender = new Sender(AppSecret); String messagePayload = &quot;消息体内容&quot;; String title = &quot;消息标题&quot;; Message message = new Message.Builder() // 编译消息体 .title(title) // 设置在通知栏展示的通知的标题 .description(description) // 设置在通知栏展示的通知描述 .payload(messagePayload) // 设置要发送的消息内容 .restrictedPackageName(PackageName) // 设置app的包名packageName, packageName必须和开发者网站上申请的结果一致 .passThrough(0) //设置消息是否通过透传的方式至App, 1表示透传消息, 0表示通知栏消息(默认是通知栏消息) .notifyId(notifyId) // 可选项, 默认情况下, 通知栏只显示一条推送消息, 如果通知栏要显示多条推送消息, 需要针对不同的消息设置不同的notify_id .notifyType(-1) // 设置通知类型, type类型支持以下值：1：使用默认提示音提示2：使用默认震动提示4：使用默认led灯光提示-1（系统默认值）：以上三种效果都有0：以上三种效果都无，即静默推送。 // 下面extra配置可以自定义打开手机app指定页面（Activity） .extra(Constants.EXTRA_PARAM_NOTIFY_EFFECT, Constants.NOTIFY_ACTIVITY) .extra(Constants.EXTRA_PARAM_INTENT_URI,&quot;intent配置需要app开发者编译好给你&quot;) .build(); Result result = sender.send(message, regId, 3); //根据regID，发送消息到指定设备上，最后一个参数没重试次数 LOGGER.info(&quot;小米推送 -- &gt;&gt; 返回结果Result:&#123;&#125;&quot;,JSON.toJSONString(result)); 到此小米推送服务集成完毕，详细参数等更多功能可以查看官方文档：https://dev.mi.com/console/doc/detail?pId=1278"},{"title":"java集成华为推送","path":"/2023/06/03/java集成华为推送/","content":"集成华为推送这类推送一般官方文档都比较详细，如果想要更加详细的了解建议查看官方文档。 官方文档地址：https://developer.huawei.com/consumer/cn/service/hms/pushservice.html 华为推送服务在开发前需要些准备 1.注册认证成为开发者 2.配置应用签名 3.创建产品和应用 4.开通推送服务 这些步骤按照官方文档一步步来就行，我这边是直接拿到了开发所需要的APPID，APP SECRET，PACKAGE NAME 注册和准备工作完成后就可以开始进行后台的代码编写了 第一步 应用服务器获取AccessToken想要访问华为的服务接口必须需要一个Token，我们第一步就是获取这个Token。 1234567private static String appSecret = &quot;appSecret&quot;;//用户在华为开发者联盟申请Push服务获取的服务参数private static String appId = &quot;12345678&quot;;//用户在华为开发者联盟申请Push服务获取的服务参数private static String tokenUrl = &quot;https://login.cloud.huawei.com/oauth2/v2/token&quot;; //获取认证Token的URLprivate static String apiUrl = &quot;https://api.push.hicloud.com/pushsend.do&quot;; //应用级消息下发APIprivate static String accessToken;//下发通知消息的认证Tokenprivate static long tokenExpiredTime; //accessToken的过期时间 首先定义好需要的参数，在实际开发中这些参数可以存放在数据库，也可以存放在配置文件中，看个人需求。 接下来就是获取Token 123456789101112private void refreshToken() &#123; try &#123; String msgBody = MessageFormat.format(&quot;grant_type=client_credentials&amp;client_secret=&#123;0&#125;&amp;client_id=&#123;1&#125;&quot;, URLEncoder.encode(appSecret, &quot;UTF-8&quot;), appId); String response = HttpUtil.post(tokenUrl, msgBody); JSONObject obj = JSONObject.parseObject(response); accessToken = obj.getString(“access_token”); tokenExpiredTime = System.currentTimeMillis()+（obj.getLong(“expires_in”)-5 * 60)*1000; &#125; catch (Exception e) &#123; LOGGER.error(&quot;HvPush -- &gt;&gt; 认证Token获取失败！原因：e = &#123;&#125;&quot;, ExceptionUtil.getMessage(e)); &#125; &#125; 获取到了访问Token我们就可以开始推送代码的编写了。 第二步 应用服务器发送PUSH消息通过前面的代码我们获取到了AccessToken,Token的存放按照不同的需求可以放在redis或者数据库。 在发送消息之前首先先验证AccessToken是否已经过期 12345if(tokenExpiredTime &lt;=System.currentTimeMillis()) &#123; refreshToken(); &#125; 接下来进行消息体的封装 1234567891011121314151617181920212223242526272829303132333435363738394041 // 封装推送消息body，用于显示通知栏消息显示的标题和内容 JSONObject body = new JSONObject();//仅通知栏消息需要设置标题和内容，透传消息key和value为用户自定义 body.put(&quot;title&quot;,&quot;Push message title&quot;);//消息标题 body.put(&quot;content&quot;,&quot;Push message content&quot;);//消息内容体 // 封装消息点击动作的参数，“com.huawei.hms.hmsdemo”为推送消息中需要打开的应用APK包名。请根据实际包名来修改。 JSONObject param = new JSONObject(); param.put(&quot;appPkgName&quot;,&quot;com.huawei.hms.hmsdemo&quot;);//定义需要打开的appPkgName，这个参数在推送服务管理页面可以看到 // 封装消息点击动作，用于定义通知栏点击行为 JSONObject action = new JSONObject(); action.put(&quot;type&quot;,3);//类型3为打开APP，其他行为请参考接口文档设置 action.put(&quot;param&quot;,param);//消息点击动作参数// type为1时可以自定义行为，自定义行为需要app开发者事先给号参数// param.put(&quot;intent&quot;, &quot;自定义行为，动作需要app开发者编辑好给你&quot;); // 封装消息类型，用于定义消息类型，区分是通知栏消息还是透传消息。 JSONObject msg = new JSONObject(); msg.put(&quot;type&quot;,3);//3: 通知栏消息，异步透传消息请根据接口文档设置 msg.put(&quot;action&quot;,action);//消息点击动作 msg.put(&quot;body&quot;,body);//通知栏消息body内容示例代码 // 封装扩展消息，扩展消息中可以设置biTag用于消息打点，也可以携带customize参数用于触发通知栏点击事件的onEvent回调。 JSONObject ext = new JSONObject();//扩展信息，含BI消息统计，特定展示风格，消息折叠。 ext.put(&quot;biTag&quot;,&quot;Trump&quot;);//设置消息标签，如果带了这个标签，会在回执中推送给CP用于检测某种类型消息的到达率和状态 JSONObject temp = new JSONObject(); temp.put(&quot;season&quot;,&quot;Spring&quot;); temp.put(&quot;weather&quot;,&quot;raining&quot;); JSONArray customize = new JSONArray(); customize.add(temp); ext.put(&quot;customize&quot;,customize); // ext扩展信息这个参数我并没理解到到底是干嘛的 ，在实际的开发中我只使用了ext.put(&quot;biTag&quot;, &quot;Trump&quot;); 并没有进行customize参数的携带 // 最后将以上信息全部封装整个消息体 JSONObject hps = new JSONObject();//华为PUSH消息总结构体 hps.put(&quot;msg&quot;,msg); hps.put(&quot;ext&quot;,ext); JSONObject payload = new JSONObject(); payload.put(&quot;hps&quot;,hps); 消息体参数详细文档地址：https://developer.huawei.com/consumer/cn/service/hms/catalog/huaweipush_agent.html?page&#x3D;hmssdk_huaweipush_api_reference_agent_s2 消息体封装完成后就可以开始发送推送消息了。 12345678910111213141516171819\t// 创建一个数组json用于存放需要推送的设备id，一般是由前段传过来，或者数据库查询出来\tJSONArray deviceTokens = new JSONArray();//目标设备Token deviceTokens.add(regId);\t// 封装整个http消息并发送\tString postBody = MessageFormat.format( &quot;access_token=&#123;0&#125;&amp;nsp_svc=&#123;1&#125;&amp;nsp_ts=&#123;2&#125;&amp;device_token_list=&#123;3&#125;&amp;payload=&#123;4&#125;&quot;, URLEncoder.encode(accessToken,&quot;UTF-8&quot;), URLEncoder.encode(&quot;openpush.message.api.send&quot;,&quot;UTF-8&quot;), URLEncoder.encode(String.valueOf(System.currentTimeMillis() / 1000),&quot;UTF-8&quot;), URLEncoder.encode(deviceTokens.toString(),&quot;UTF-8&quot;), URLEncoder.encode(payload.toString(),&quot;UTF-8&quot;));String postUrl = apiUrl + &quot;?nsp_ctx=&quot; + URLEncoder.encode(&quot;&#123;\\&quot;ver\\&quot;:\\&quot;1\\&quot;, \\&quot;appId\\&quot;:\\&quot;&quot; + appId + &quot;\\&quot;&#125;&quot;, &quot;UTF-8&quot;);\t// 发送消息 这里我用的是hutool的HttpUtil工具类发的post请求 String post = HttpUtil.post(postUrl, postBody); LOGGER.info(&quot;华为推送 -- &gt;&gt; 返回结果：&quot; + post); 到此推送完成，返回结果与错误代码对应文档地址：https://developer.huawei.com/consumer/cn/service/hms/catalog/huaweipush_agent.html?page&#x3D;hmssdk_huaweipush_api_reference_agent_s2"},{"title":"ftps上传遇到到的一些坑","path":"/2023/06/03/ftps上传遇到到的一些坑/","content":"接上次ftps部署上传在实际使用部署过程中遇到的一些问题,由于实际使用时对接的是第三方部署好的ftps服务器碰到的一些问题 1.未设置ftps连接超时时间导致在进行连接失败时线程阻塞卡死首次连接时发现开始连接后就没有连接成功日志,同样也没有报错日志,这时只能在每一步进行时添加对应的日志打印,然后发现线程执行到ftpsClient.connect(host, port)时就没有下一步的日志了,添加连接超时失败时间,防止线程卡死; 1234// 设置连接超时时间为30秒ftpsClient.setConnectTimeout(30*1000);// 设置读取超时时间也为30秒ftpsClient.setDataTimeout(30*1000); 2.对方ftps服务器设置了安全模式为隐式模式导致连接超时无法连接设置超时时间后发现到超时时间后依然无法成功连接到对方ftps服务器,由于对方没有技术回答问题只能不断尝试后发现设置的隐式模式,创建ftps对象时不设置安全模式会默认为使用显示模式; 创建连接对象时设置安全模式为显示 1FTPSClient ftpsClient = new FTPSClient(&quot;TlS&quot;,true); 3.由于双方都使用了路由器NAT进行ip映射导致ftps无法连接由于环境原因双方服务器都在路由器下局域网环境部署,内网访问需要通过路由器进行NAT转接后才能访问,导致无法连接,详细原因参考https://blog.csdn.net/cheng_fangang/article/details/7395442 这个大佬的分析,解决方法添加NAT特殊设置 12// 设置重定向地址为连接ftps服务器的真实地址ftpsClient.setPassiveNatWorkaroundStrategy((hostname -&gt; host));"},{"title":"redis 分布式锁实现","path":"/2023/06/03/redis-分布式锁实现/","content":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283/** * 获取锁 * * @param lockKey 锁key * @param value 锁值 一般随机生成 * @param expireTime：单位-秒 * @return 成功猎取锁返回true */public boolean getLock(String lockKey, String value, int expireTime) &#123; try &#123; String script = &quot;if redis.call(&#x27;setNx&#x27;,KEYS[1],ARGV[1]) then if redis.call(&#x27;get&#x27;,KEYS[1])==ARGV[1] then return redis.call(&#x27;expire&#x27;,KEYS[1],ARGV[2]) else return 0 end end&quot;; RedisScript&lt;Long&gt; redisScript = new DefaultRedisScript&lt;&gt;(script, Long.class); Object result = this.redisTemplate.execute(redisScript, Collections.singletonList(lockKey), value, expireTime); if (SUCCESS.equals(result)) &#123; return true; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; return false;&#125;/** * 释放锁 * * @param lockKey 锁key * @param value 锁值 获取锁时随机生成的串 * @return */public boolean releaseLock(String lockKey, String value) &#123; String script = &quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then return redis.call(&#x27;del&#x27;, KEYS[1]) else return 0 end&quot;; RedisScript&lt;Long&gt; redisScript = new DefaultRedisScript&lt;&gt;(script, Long.class); Object result = this.redisTemplate.execute(redisScript, Collections.singletonList(lockKey), value); if (SUCCESS.equals(result)) &#123; return true; &#125; return false;&#125;/** * 获取查询锁,返回锁标识 * * @param lockName 锁的key * @param acquireTimeout 获取锁超时时间 ms * @param timeout 锁的超时时间 ms * @return 锁标识UUID */public String lockWithTimeout(String lockName, int acquireTimeout, int timeout) &#123; // 随机生成一个value String value = UUID.randomUUID().toString(); if(lockWithTimeout(lockName, value, acquireTimeout, timeout)) &#123; return value; &#125; return null;&#125;/** * 获取查询锁 * @param lockName 锁的key * @param requestId 请求标识码 * @param acquireTimeout 获取锁超时时间 ms * @param timeout 锁的超时时间 ms * @return */public boolean lockWithTimeout(String lockName, String requestId, int acquireTimeout, int timeout) &#123; // 超时时间，上锁后超过此时间则自动释放锁 int lockExpire = timeout / 1000; // 获取锁的超时时间，超过这个时间则放弃获取锁 long end = System.currentTimeMillis() + acquireTimeout; while (System.currentTimeMillis() &lt; end) &#123; if (getLock(lockName, requestId, lockExpire)) &#123; return true; &#125; try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; Thread.currentThread().interrupt(); &#125; &#125; return false;&#125;"}]