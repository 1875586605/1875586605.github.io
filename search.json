[{"title":"Markdown 编辑器Editor.md简单集成","path":"/2023/06/03/Markdown-编辑器Editor-md简单集成/","content":"既然要集成，第一步就是找到来源，直接到官方网站下载依赖。 官方网站地址：https://pandao.github.io/editor.md/ 下载之后解压下载文件 要是用的依赖基本就是用红框标注出来的，将需要的依赖丢入自己项目中的resources目录下 找到文本输入框的html，开始引入依赖。 12345678// 引入css样式文件&lt;link rel=&quot;stylesheet&quot; href=&quot;/css/editormd.css&quot; /&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;/css/editormd.preview.min.css&quot; /&gt;// 引入js等依赖&lt;script src=&quot;/js/jquery-3.2.1.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;/js/editormd.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;/lib/prettify.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;/lib/marked.min.js&quot;&gt;&lt;/script&gt; 将文本输入框替换为Markdown编辑器 123&lt;div id=&quot;test-editormd&quot;&gt;\t&lt;textarea placeholder=&quot;正文&quot; style=&quot;display:none;&quot;&gt;&lt;/textarea&gt;&lt;/div&gt; 初始化Markdown编辑器的js 12345678910111213141516171819202122&lt;script type=&quot;text/javascript&quot;&gt; var testEditor; $(function () &#123; testEditor = editormd(&quot;test-editormd&quot;, &#123; // test-editormd为之前定义编辑器所在div的id width: &quot;98%&quot;, height: 300, syncScrolling: &quot;single&quot;, path: &quot;/lib/&quot;, //你的path路径（原资源文件中lib包在我们项目中所放的位置） saveHTMLToTextarea: true, emoji: true, taskList: true, tex: true, flowChart: true, tocm: true, sequenceDiagram: true, /* 上传图片配置 */ imageUpload: false, imageFormats: [&quot;jpg&quot;, &quot;jpeg&quot;, &quot;gif&quot;, &quot;png&quot;, &quot;bmp&quot;, &quot;webp&quot;], // 上传图片支持格式 imageUploadURL: &quot;../imageUpload&quot; // 上传图片的路径 &#125;); &#125;);&lt;/script&gt; 以上集成编辑器就完成了，接下来就是讲取出来的数据展示出来。 第一步依旧是引入所需依赖 1234567891011&lt;link rel=&quot;stylesheet&quot; href=&quot;/css/editormd.css&quot; /&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;/css/editormd.preview.min.css&quot; /&gt;&lt;script src=&quot;/js/jquery-3.2.1.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;/lib/marked.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;/lib/prettify.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;/lib/raphael.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;/lib/underscore.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;/lib/sequence-diagram.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;/lib/flowchart.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;/lib/jquery.flowchart.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;/js/editormd.min.js&quot;&gt;&lt;/script&gt; 页面显示的div 123&lt;div id=&quot;test-editormd&quot; &gt; &lt;textarea style=&quot;display:none;&quot;&gt;&lt;/textarea&gt;&lt;/div&gt; 解析的js 12345678910&lt;script type=&quot;text/javascript&quot;&gt; editormd.markdownToHTML(&quot;test-editormd&quot;, &#123; htmlDecode : &quot;style,script,iframe&quot;, emoji : true, taskList : true, tex : true, // 默认不解析 flowChart : true, // 默认不解析 sequenceDiagram : true // 默认不解析 &#125;);&lt;/script&gt; 到此就完成了Markdown 编辑器Editor.md简单集成。"},{"title":"elasticsearchTemplate的聚合查询","path":"/2023/06/03/elasticsearchTemplate的聚合查询/","content":"直接上代码： 1234567891011121314151617181920212223242526// 创建一个查询条件对象BoolQueryBuilder queryBuilder = QueryBuilders.boolQuery();// 拼接查询条件queryBuilder.should(QueryBuilders.termQuery(&quot;字段&quot;, &quot;值&quot;))；// 创建聚合查询条件TermsAggregationBuilder agg = AggregationBuilders.terms(&quot;聚合名称，自定义，取出时会用到&quot;).field(&quot;聚合字段&quot;).size(100)；// size是查询聚合出来的条数// 创建查询对象SearchQuery build = new NativeSearchQueryBuilder() .withQuery(queryBuilder) //添加查询条件 .addAggregation(agg) // 添加聚合条件 .withPageable(PageRequest.of(0, 1)) //符合查询条件的文档分页（不是聚合的分页） .build();// 执行查询AggregatedPage&lt;TestEntity&gt; testEntities = elasticsearchTemplate.queryForPage(build, TestEntity.class);// 取出聚合结果Aggregations entitiesAggregations = testEntities.getAggregations(); Terms terms = (Terms)propertyInfoEntities.getAggregation(&quot;聚合名称，之前自定义的&quot;);// 遍历取出聚合字段列的值，与对应的数量for (Terms.Bucket bucket : terms.getBuckets()) &#123; String keyAsString = bucket.getKeyAsString(); // 聚合字段列的值 long docCount = bucket.getDocCount();// 聚合字段对应的数量 &#125; 多字段聚合： 12345678910111213141516171819202122232425262728293031323334353637// 创建一个查询条件对象BoolQueryBuilder queryBuilder = QueryBuilders.boolQuery();// 拼接查询条件queryBuilder.should(QueryBuilders.termQuery(&quot;字段&quot;, &quot;值&quot;))；// 创建聚合查询条件TermsAggregationBuilder agg1 = AggregationBuilders.terms(&quot;聚合名称2&quot;).field(聚合字段2).size(100)TermsAggregationBuilder agg = AggregationBuilders.terms(&quot;聚合名称1&quot;).field(&quot;聚合字段1&quot;).size(100).subAggregation(agg1)//拼接上上一个聚合条件// 创建查询对象SearchQuery build = new NativeSearchQueryBuilder() .withQuery(queryBuilder) //添加查询条件 .addAggregation(agg) // 添加聚合条件 .withPageable(PageRequest.of(0, 1)) //符合查询条件的文档分页（不是聚合的分页） .build();// 执行查询AggregatedPage&lt;TestEntity&gt; testEntities = elasticsearchTemplate.queryForPage(build, TestEntity.class);// 取出聚合结果Aggregations entitiesAggregations = testEntities.getAggregations(); Terms terms = (Terms)propertyInfoEntities.getAggregation(&quot;聚合名称&quot;);// 遍历最外层的聚合结果for (Terms.Bucket bucket : terms.getBuckets()) &#123; String keyAsString = bucket.getKeyAsString(); // 聚合字段列的名称 long docCount = bucket.getDocCount();// 聚合字段对应的数量 // 获取内部的聚合字段信息 Aggregations aggregations = bucket.getAggregations(); Terms terms2 = aggregations.get(&quot;聚合名称2&quot;);\t// 遍历获取agg1的聚合信息\tfor (Terms.Bucket bucket1 : terms2.getBuckets()) &#123; String keyAsString2 = bucket.getKeyAsString(); // 聚合字段列的名称 long docCount2 = bucket.getDocCount();// 聚合字段对应的数量 &#125; &#125; 多个字段一次性聚合： 123456789101112131415161718192021222324252627282930// 创建一个查询条件对象BoolQueryBuilder queryBuilder = QueryBuilders.boolQuery();// 拼接查询条件queryBuilder.should(QueryBuilders.termQuery(&quot;字段&quot;, &quot;值&quot;))；// 创建聚合查询条件String script = &quot;doc[&#x27;&quot; + 字段1 + &quot;&#x27;].values +&#x27;/&#x27;+ doc[&#x27;&quot; + 字段2 + &quot;&#x27;].values +&#x27;/&#x27;+ doc[&#x27;&quot; + 字段3 + &quot;&#x27;].values&quot;; // 编写script语句Script script1 = new Script(script); // 新建一个script对象TermsAggregationBuilder agg = AggregationBuilders.terms(&quot;聚合名称&quot;).script(script1).size(99999); // 创建一个聚合查询对象SearchQuery build = new NativeSearchQueryBuilder() .withQuery(queryBuilder) //添加查询条件 .addAggregation(agg) // 添加聚合条件 .withPageable(PageRequest.of(0, 1)) //符合查询条件的文档分页（不是聚合的分页） .build();// 执行查询AggregatedPage&lt;TestEntity&gt; testEntities = elasticsearchTemplate.queryForPage(build, TestEntity.class);Terms terms = (Terms) shopDbEntities.getAggregation(&quot;聚合名称&quot;);for (Terms.Bucket bucket : terms.getBuckets()) &#123; // 循环取出聚合的值 String keyAsString = bucket.getKeyAsString(); String[] split = keyAsString.split(&quot;/&quot;); // 切割取出每个字段 System.out.println(&quot;字段1&quot;+split[0]); System.out.println(&quot;字段2&quot;+split[1]); System.out.println(&quot;字段3&quot;+split[2]); &#125; 更多字段聚合按照以上类推，如果实在对于结构不理解可以将查询语句打印出来，将打印语句拿到Kibana之类的查询工具中查询看下结构，或者直接Debug看下数据结构，就比较好理解了"},{"title":"springBoot集成es使用ElasticsearchTemplate执行滚动查询","path":"/2023/06/03/springBoot集成es使用ElasticsearchTemplate执行滚动查询/","content":"使用Elasticsearch查询大量数据时基本的分页查询就会报错，这种情况下可以使用scroll（滚动）查询 直接上代码： 123456789101112131415161718192021222324252627// 创建查询条件对象BoolQueryBuilder queryBuilder = QueryBuilders.boolQuery();// 拼接查询条件queryBuilder.must(QueryBuilders.termQuery(&quot;status&quot;, 1)); 假设查询状态为1的// 创建查询对象SearchQuery searchQuery = new NativeSearchQueryBuilder() .withIndices(&quot;test_index&quot;)//索引名 .withTypes(&quot;test&quot;)//类型名 .withQuery(queryBuilder)// 查询条件对象 .withPageable(PageRequest.of(0, 1000))//从0页开始查，每页1000个结果 .build();// 滚动查询ScrolledPage&lt;TestEntity&gt; scroll = (ScrolledPage&lt;TestEntity&gt;) elasticsearchTemplate.startScroll(3000, searchQuery, TestEntity.class);// 判断是否有内容while (scroll.hasContent()) &#123;\tList&lt;TestEntity&gt; content = scroll.getContent();\t// 业务逻辑省略\t//取下一页，scrollId在es服务器上可能会发生变化，需要用最新的。发起continueScroll请求会重新刷新快照保留时间\tscroll = (ScrolledPage&lt;TestEntity&gt;) elasticsearchTemplate.continueScroll(scroll.getScrollId(), 3000, EstateInfoEntity.class);&#125;// 最后释放查询elasticsearchTemplate.clearScroll(scroll.getScrollId());"},{"title":"java集成小米推送服务","path":"/2023/06/03/java集成小米推送服务/","content":"集成小米推送服务这类推送一般官方文档都比较详细，如果想要更加详细的了解建议查看官方文档 官方文档地址：https://dev.mi.com/console/appservice/push.html 在正式开发前需要做一些准备 1、开发者需要登录开发者网站进入推送服务(申请AppID, AppKey, AppSecret) 2、访问开发者网站下载SDK； 将下载的SDK解压，将文件夹中的2个依赖jar包丢入项目工程的libs目录 接下来就是发送消息了 1234567891011121314151617181920212223// 正式环境下使用Push服务，启动时需要调用如下代码Constants.useOfficial(); // 测试环境下使用Push服务，启动时需要调用如下代码// Constants.useSandbox(); Sender sender = new Sender(AppSecret); String messagePayload = &quot;消息体内容&quot;; String title = &quot;消息标题&quot;; Message message = new Message.Builder() // 编译消息体 .title(title) // 设置在通知栏展示的通知的标题 .description(description) // 设置在通知栏展示的通知描述 .payload(messagePayload) // 设置要发送的消息内容 .restrictedPackageName(PackageName) // 设置app的包名packageName, packageName必须和开发者网站上申请的结果一致 .passThrough(0) //设置消息是否通过透传的方式至App, 1表示透传消息, 0表示通知栏消息(默认是通知栏消息) .notifyId(notifyId) // 可选项, 默认情况下, 通知栏只显示一条推送消息, 如果通知栏要显示多条推送消息, 需要针对不同的消息设置不同的notify_id .notifyType(-1) // 设置通知类型, type类型支持以下值：1：使用默认提示音提示2：使用默认震动提示4：使用默认led灯光提示-1（系统默认值）：以上三种效果都有0：以上三种效果都无，即静默推送。 // 下面extra配置可以自定义打开手机app指定页面（Activity） .extra(Constants.EXTRA_PARAM_NOTIFY_EFFECT, Constants.NOTIFY_ACTIVITY) .extra(Constants.EXTRA_PARAM_INTENT_URI,&quot;intent配置需要app开发者编译好给你&quot;) .build(); Result result = sender.send(message, regId, 3); //根据regID，发送消息到指定设备上，最后一个参数没重试次数 LOGGER.info(&quot;小米推送 -- &gt;&gt; 返回结果Result:&#123;&#125;&quot;,JSON.toJSONString(result)); 到此小米推送服务集成完毕，详细参数等更多功能可以查看官方文档：https://dev.mi.com/console/doc/detail?pId=1278"},{"title":"java集成华为推送","path":"/2023/06/03/java集成华为推送/","content":"集成华为推送这类推送一般官方文档都比较详细，如果想要更加详细的了解建议查看官方文档。 官方文档地址：https://developer.huawei.com/consumer/cn/service/hms/pushservice.html 华为推送服务在开发前需要些准备 1.注册认证成为开发者 2.配置应用签名 3.创建产品和应用 4.开通推送服务 这些步骤按照官方文档一步步来就行，我这边是直接拿到了开发所需要的APPID，APP SECRET，PACKAGE NAME 注册和准备工作完成后就可以开始进行后台的代码编写了 第一步 应用服务器获取AccessToken想要访问华为的服务接口必须需要一个Token，我们第一步就是获取这个Token。 1234567private static String appSecret = &quot;appSecret&quot;;//用户在华为开发者联盟申请Push服务获取的服务参数private static String appId = &quot;12345678&quot;;//用户在华为开发者联盟申请Push服务获取的服务参数private static String tokenUrl = &quot;https://login.cloud.huawei.com/oauth2/v2/token&quot;; //获取认证Token的URLprivate static String apiUrl = &quot;https://api.push.hicloud.com/pushsend.do&quot;; //应用级消息下发APIprivate static String accessToken;//下发通知消息的认证Tokenprivate static long tokenExpiredTime; //accessToken的过期时间 首先定义好需要的参数，在实际开发中这些参数可以存放在数据库，也可以存放在配置文件中，看个人需求。 接下来就是获取Token 123456789101112private void refreshToken() &#123; try &#123; String msgBody = MessageFormat.format(&quot;grant_type=client_credentials&amp;client_secret=&#123;0&#125;&amp;client_id=&#123;1&#125;&quot;, URLEncoder.encode(appSecret, &quot;UTF-8&quot;), appId); String response = HttpUtil.post(tokenUrl, msgBody); JSONObject obj = JSONObject.parseObject(response); accessToken = obj.getString(“access_token”); tokenExpiredTime = System.currentTimeMillis()+（obj.getLong(“expires_in”)-5 * 60)*1000; &#125; catch (Exception e) &#123; LOGGER.error(&quot;HvPush -- &gt;&gt; 认证Token获取失败！原因：e = &#123;&#125;&quot;, ExceptionUtil.getMessage(e)); &#125; &#125; 获取到了访问Token我们就可以开始推送代码的编写了。 第二步 应用服务器发送PUSH消息通过前面的代码我们获取到了AccessToken,Token的存放按照不同的需求可以放在redis或者数据库。 在发送消息之前首先先验证AccessToken是否已经过期 12345if(tokenExpiredTime &lt;=System.currentTimeMillis()) &#123; refreshToken(); &#125; 接下来进行消息体的封装 1234567891011121314151617181920212223242526272829303132333435363738394041 // 封装推送消息body，用于显示通知栏消息显示的标题和内容 JSONObject body = new JSONObject();//仅通知栏消息需要设置标题和内容，透传消息key和value为用户自定义 body.put(&quot;title&quot;,&quot;Push message title&quot;);//消息标题 body.put(&quot;content&quot;,&quot;Push message content&quot;);//消息内容体 // 封装消息点击动作的参数，“com.huawei.hms.hmsdemo”为推送消息中需要打开的应用APK包名。请根据实际包名来修改。 JSONObject param = new JSONObject(); param.put(&quot;appPkgName&quot;,&quot;com.huawei.hms.hmsdemo&quot;);//定义需要打开的appPkgName，这个参数在推送服务管理页面可以看到 // 封装消息点击动作，用于定义通知栏点击行为 JSONObject action = new JSONObject(); action.put(&quot;type&quot;,3);//类型3为打开APP，其他行为请参考接口文档设置 action.put(&quot;param&quot;,param);//消息点击动作参数// type为1时可以自定义行为，自定义行为需要app开发者事先给号参数// param.put(&quot;intent&quot;, &quot;自定义行为，动作需要app开发者编辑好给你&quot;); // 封装消息类型，用于定义消息类型，区分是通知栏消息还是透传消息。 JSONObject msg = new JSONObject(); msg.put(&quot;type&quot;,3);//3: 通知栏消息，异步透传消息请根据接口文档设置 msg.put(&quot;action&quot;,action);//消息点击动作 msg.put(&quot;body&quot;,body);//通知栏消息body内容示例代码 // 封装扩展消息，扩展消息中可以设置biTag用于消息打点，也可以携带customize参数用于触发通知栏点击事件的onEvent回调。 JSONObject ext = new JSONObject();//扩展信息，含BI消息统计，特定展示风格，消息折叠。 ext.put(&quot;biTag&quot;,&quot;Trump&quot;);//设置消息标签，如果带了这个标签，会在回执中推送给CP用于检测某种类型消息的到达率和状态 JSONObject temp = new JSONObject(); temp.put(&quot;season&quot;,&quot;Spring&quot;); temp.put(&quot;weather&quot;,&quot;raining&quot;); JSONArray customize = new JSONArray(); customize.add(temp); ext.put(&quot;customize&quot;,customize); // ext扩展信息这个参数我并没理解到到底是干嘛的 ，在实际的开发中我只使用了ext.put(&quot;biTag&quot;, &quot;Trump&quot;); 并没有进行customize参数的携带 // 最后将以上信息全部封装整个消息体 JSONObject hps = new JSONObject();//华为PUSH消息总结构体 hps.put(&quot;msg&quot;,msg); hps.put(&quot;ext&quot;,ext); JSONObject payload = new JSONObject(); payload.put(&quot;hps&quot;,hps); 消息体参数详细文档地址：https://developer.huawei.com/consumer/cn/service/hms/catalog/huaweipush_agent.html?page&#x3D;hmssdk_huaweipush_api_reference_agent_s2 消息体封装完成后就可以开始发送推送消息了。 12345678910111213141516171819\t// 创建一个数组json用于存放需要推送的设备id，一般是由前段传过来，或者数据库查询出来\tJSONArray deviceTokens = new JSONArray();//目标设备Token deviceTokens.add(regId);\t// 封装整个http消息并发送\tString postBody = MessageFormat.format( &quot;access_token=&#123;0&#125;&amp;nsp_svc=&#123;1&#125;&amp;nsp_ts=&#123;2&#125;&amp;device_token_list=&#123;3&#125;&amp;payload=&#123;4&#125;&quot;, URLEncoder.encode(accessToken,&quot;UTF-8&quot;), URLEncoder.encode(&quot;openpush.message.api.send&quot;,&quot;UTF-8&quot;), URLEncoder.encode(String.valueOf(System.currentTimeMillis() / 1000),&quot;UTF-8&quot;), URLEncoder.encode(deviceTokens.toString(),&quot;UTF-8&quot;), URLEncoder.encode(payload.toString(),&quot;UTF-8&quot;));String postUrl = apiUrl + &quot;?nsp_ctx=&quot; + URLEncoder.encode(&quot;&#123;\\&quot;ver\\&quot;:\\&quot;1\\&quot;, \\&quot;appId\\&quot;:\\&quot;&quot; + appId + &quot;\\&quot;&#125;&quot;, &quot;UTF-8&quot;);\t// 发送消息 这里我用的是hutool的HttpUtil工具类发的post请求 String post = HttpUtil.post(postUrl, postBody); LOGGER.info(&quot;华为推送 -- &gt;&gt; 返回结果：&quot; + post); 到此推送完成，返回结果与错误代码对应文档地址：https://developer.huawei.com/consumer/cn/service/hms/catalog/huaweipush_agent.html?page&#x3D;hmssdk_huaweipush_api_reference_agent_s2"},{"title":"ftps上传遇到到的一些坑","path":"/2023/06/03/ftps上传遇到到的一些坑/","content":"接上次ftps部署上传在实际使用部署过程中遇到的一些问题,由于实际使用时对接的是第三方部署好的ftps服务器碰到的一些问题 1.未设置ftps连接超时时间导致在进行连接失败时线程阻塞卡死首次连接时发现开始连接后就没有连接成功日志,同样也没有报错日志,这时只能在每一步进行时添加对应的日志打印,然后发现线程执行到ftpsClient.connect(host, port)时就没有下一步的日志了,添加连接超时失败时间,防止线程卡死; 1234// 设置连接超时时间为30秒ftpsClient.setConnectTimeout(30*1000);// 设置读取超时时间也为30秒ftpsClient.setDataTimeout(30*1000); 2.对方ftps服务器设置了安全模式为隐式模式导致连接超时无法连接设置超时时间后发现到超时时间后依然无法成功连接到对方ftps服务器,由于对方没有技术回答问题只能不断尝试后发现设置的隐式模式,创建ftps对象时不设置安全模式会默认为使用显示模式; 创建连接对象时设置安全模式为显示 1FTPSClient ftpsClient = new FTPSClient(&quot;TlS&quot;,true); 3.由于双方都使用了路由器NAT进行ip映射导致ftps无法连接由于环境原因双方服务器都在路由器下局域网环境部署,内网访问需要通过路由器进行NAT转接后才能访问,导致无法连接,详细原因参考https://blog.csdn.net/cheng_fangang/article/details/7395442 这个大佬的分析,解决方法添加NAT特殊设置 12// 设置重定向地址为连接ftps服务器的真实地址ftpsClient.setPassiveNatWorkaroundStrategy((hostname -&gt; host));"},{"title":"redis 分布式锁实现","path":"/2023/06/03/redis-分布式锁实现/","content":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283/** * 获取锁 * * @param lockKey 锁key * @param value 锁值 一般随机生成 * @param expireTime：单位-秒 * @return 成功猎取锁返回true */public boolean getLock(String lockKey, String value, int expireTime) &#123; try &#123; String script = &quot;if redis.call(&#x27;setNx&#x27;,KEYS[1],ARGV[1]) then if redis.call(&#x27;get&#x27;,KEYS[1])==ARGV[1] then return redis.call(&#x27;expire&#x27;,KEYS[1],ARGV[2]) else return 0 end end&quot;; RedisScript&lt;Long&gt; redisScript = new DefaultRedisScript&lt;&gt;(script, Long.class); Object result = this.redisTemplate.execute(redisScript, Collections.singletonList(lockKey), value, expireTime); if (SUCCESS.equals(result)) &#123; return true; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; return false;&#125;/** * 释放锁 * * @param lockKey 锁key * @param value 锁值 获取锁时随机生成的串 * @return */public boolean releaseLock(String lockKey, String value) &#123; String script = &quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then return redis.call(&#x27;del&#x27;, KEYS[1]) else return 0 end&quot;; RedisScript&lt;Long&gt; redisScript = new DefaultRedisScript&lt;&gt;(script, Long.class); Object result = this.redisTemplate.execute(redisScript, Collections.singletonList(lockKey), value); if (SUCCESS.equals(result)) &#123; return true; &#125; return false;&#125;/** * 获取查询锁,返回锁标识 * * @param lockName 锁的key * @param acquireTimeout 获取锁超时时间 ms * @param timeout 锁的超时时间 ms * @return 锁标识UUID */public String lockWithTimeout(String lockName, int acquireTimeout, int timeout) &#123; // 随机生成一个value String value = UUID.randomUUID().toString(); if(lockWithTimeout(lockName, value, acquireTimeout, timeout)) &#123; return value; &#125; return null;&#125;/** * 获取查询锁 * @param lockName 锁的key * @param requestId 请求标识码 * @param acquireTimeout 获取锁超时时间 ms * @param timeout 锁的超时时间 ms * @return */public boolean lockWithTimeout(String lockName, String requestId, int acquireTimeout, int timeout) &#123; // 超时时间，上锁后超过此时间则自动释放锁 int lockExpire = timeout / 1000; // 获取锁的超时时间，超过这个时间则放弃获取锁 long end = System.currentTimeMillis() + acquireTimeout; while (System.currentTimeMillis() &lt; end) &#123; if (getLock(lockName, requestId, lockExpire)) &#123; return true; &#125; try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; Thread.currentThread().interrupt(); &#125; &#125; return false;&#125;"}]